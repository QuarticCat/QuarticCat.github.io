<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++ 类型阅读入门 | QuarticCat's Blog</title>
<meta name=keywords content="cpp"><meta name=description content="C++ 的类型可读性很差，并且大多数入门材料中并没有详细介绍如何阅读它们，最多只是讲到 top-level const 和 low-level const 的区别。有不少朋友问过我这方面的问题，讲得多了，干脆整理起来写篇文章。
常见误解 在详细讲类型的阅读之前，需要纠正一个常见的误解。
问：int a[5] 里的 a 是什么类型的？
答：int[5] 类型，在适当的时候会「退化」（decay）成为 int* 类型。
问：int a[5][6] 里的 a 是什么类型的？
答：int[5][6] 类型，在适当的时候会「退化」成为 int(*)[6] 类型，即指向 int[6] 的指针。
由于「退化」这种隐式转换的存在，很多初学 C++ 的人会把数组类型等同于指针类型。
类似的，函数类型也会「退化」到指针类型，如 int(int, int) 会「退化」成为 int(*)(int, int)。
解方程 当你查阅如何阅读一些复杂的类型时，你可能会看到网络上一些人说 C++ 的类型就是解方程，让我来详细解释一下这句话。
抛去 CVR (const, volatile, reference) 等不谈，C++ 最基本的声明分为两个部分：写在最左边的类型名是「类型说明符」（type specifier），剩下的部分是「声明符」（declarator）。这部分内容是从 C 继承过来的，它们是 C++ 类型里最恶心的地方。但这两个名字实在没啥识别度，我喜欢不严谨地称呼为返回值类型和调用表达式，这点后面会解释。先来看几个例子吧：
声明 类型说明符 声明符 int a int a int* a int *a int a[5] int a[5] int* a[5] int *a[5] int (*a)[5] int (*a)[5] 作出这种分别后，就可以理解上表中a的类型是怎样决定的了：以「声明符」的形式调用a后，得到的返回值类型为「类型说明符」。所谓的解方程就是这样一个过程："><meta name=author content="QuarticCat"><link rel=canonical href=https://blog.quarticcat.com/zh/posts/read-cpp-types/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.quarticcat.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.quarticcat.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.quarticcat.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.quarticcat.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.quarticcat.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://blog.quarticcat.com/zh/posts/read-cpp-types/><link rel=alternate hreflang=en href=https://blog.quarticcat.com/posts/read-cpp-types/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "f4a0d5ded0bc48e19ea90f852a11cb57"}'></script><meta property="og:title" content="C++ 类型阅读入门"><meta property="og:description" content="C++ 的类型可读性很差，并且大多数入门材料中并没有详细介绍如何阅读它们，最多只是讲到 top-level const 和 low-level const 的区别。有不少朋友问过我这方面的问题，讲得多了，干脆整理起来写篇文章。
常见误解 在详细讲类型的阅读之前，需要纠正一个常见的误解。
问：int a[5] 里的 a 是什么类型的？
答：int[5] 类型，在适当的时候会「退化」（decay）成为 int* 类型。
问：int a[5][6] 里的 a 是什么类型的？
答：int[5][6] 类型，在适当的时候会「退化」成为 int(*)[6] 类型，即指向 int[6] 的指针。
由于「退化」这种隐式转换的存在，很多初学 C++ 的人会把数组类型等同于指针类型。
类似的，函数类型也会「退化」到指针类型，如 int(int, int) 会「退化」成为 int(*)(int, int)。
解方程 当你查阅如何阅读一些复杂的类型时，你可能会看到网络上一些人说 C++ 的类型就是解方程，让我来详细解释一下这句话。
抛去 CVR (const, volatile, reference) 等不谈，C++ 最基本的声明分为两个部分：写在最左边的类型名是「类型说明符」（type specifier），剩下的部分是「声明符」（declarator）。这部分内容是从 C 继承过来的，它们是 C++ 类型里最恶心的地方。但这两个名字实在没啥识别度，我喜欢不严谨地称呼为返回值类型和调用表达式，这点后面会解释。先来看几个例子吧：
声明 类型说明符 声明符 int a int a int* a int *a int a[5] int a[5] int* a[5] int *a[5] int (*a)[5] int (*a)[5] 作出这种分别后，就可以理解上表中a的类型是怎样决定的了：以「声明符」的形式调用a后，得到的返回值类型为「类型说明符」。所谓的解方程就是这样一个过程："><meta property="og:type" content="article"><meta property="og:url" content="https://blog.quarticcat.com/zh/posts/read-cpp-types/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-02-13T00:00:00+00:00"><meta property="article:modified_time" content="2021-02-13T00:00:00+00:00"><meta property="og:site_name" content="QuarticCat's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++ 类型阅读入门"><meta name=twitter:description content="C++ 的类型可读性很差，并且大多数入门材料中并没有详细介绍如何阅读它们，最多只是讲到 top-level const 和 low-level const 的区别。有不少朋友问过我这方面的问题，讲得多了，干脆整理起来写篇文章。
常见误解 在详细讲类型的阅读之前，需要纠正一个常见的误解。
问：int a[5] 里的 a 是什么类型的？
答：int[5] 类型，在适当的时候会「退化」（decay）成为 int* 类型。
问：int a[5][6] 里的 a 是什么类型的？
答：int[5][6] 类型，在适当的时候会「退化」成为 int(*)[6] 类型，即指向 int[6] 的指针。
由于「退化」这种隐式转换的存在，很多初学 C++ 的人会把数组类型等同于指针类型。
类似的，函数类型也会「退化」到指针类型，如 int(int, int) 会「退化」成为 int(*)(int, int)。
解方程 当你查阅如何阅读一些复杂的类型时，你可能会看到网络上一些人说 C++ 的类型就是解方程，让我来详细解释一下这句话。
抛去 CVR (const, volatile, reference) 等不谈，C++ 最基本的声明分为两个部分：写在最左边的类型名是「类型说明符」（type specifier），剩下的部分是「声明符」（declarator）。这部分内容是从 C 继承过来的，它们是 C++ 类型里最恶心的地方。但这两个名字实在没啥识别度，我喜欢不严谨地称呼为返回值类型和调用表达式，这点后面会解释。先来看几个例子吧：
声明 类型说明符 声明符 int a int a int* a int *a int a[5] int a[5] int* a[5] int *a[5] int (*a)[5] int (*a)[5] 作出这种分别后，就可以理解上表中a的类型是怎样决定的了：以「声明符」的形式调用a后，得到的返回值类型为「类型说明符」。所谓的解方程就是这样一个过程："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.quarticcat.com/zh/posts/"},{"@type":"ListItem","position":2,"name":"C++ 类型阅读入门","item":"https://blog.quarticcat.com/zh/posts/read-cpp-types/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ 类型阅读入门","name":"C\u002b\u002b 类型阅读入门","description":"C++ 的类型可读性很差，并且大多数入门材料中并没有详细介绍如何阅读它们，最多只是讲到 top-level const 和 low-level const 的区别。有不少朋友问过我这方面的问题，讲得多了，干脆整理起来写篇文章。\n常见误解 在详细讲类型的阅读之前，需要纠正一个常见的误解。\n问：int a[5] 里的 a 是什么类型的？\n答：int[5] 类型，在适当的时候会「退化」（decay）成为 int* 类型。\n问：int a[5][6] 里的 a 是什么类型的？\n答：int[5][6] 类型，在适当的时候会「退化」成为 int(*)[6] 类型，即指向 int[6] 的指针。\n由于「退化」这种隐式转换的存在，很多初学 C++ 的人会把数组类型等同于指针类型。\n类似的，函数类型也会「退化」到指针类型，如 int(int, int) 会「退化」成为 int(*)(int, int)。\n解方程 当你查阅如何阅读一些复杂的类型时，你可能会看到网络上一些人说 C++ 的类型就是解方程，让我来详细解释一下这句话。\n抛去 CVR (const, volatile, reference) 等不谈，C++ 最基本的声明分为两个部分：写在最左边的类型名是「类型说明符」（type specifier），剩下的部分是「声明符」（declarator）。这部分内容是从 C 继承过来的，它们是 C++ 类型里最恶心的地方。但这两个名字实在没啥识别度，我喜欢不严谨地称呼为返回值类型和调用表达式，这点后面会解释。先来看几个例子吧：\n声明 类型说明符 声明符 int a int a int* a int *a int a[5] int a[5] int* a[5] int *a[5] int (*a)[5] int (*a)[5] 作出这种分别后，就可以理解上表中a的类型是怎样决定的了：以「声明符」的形式调用a后，得到的返回值类型为「类型说明符」。所谓的解方程就是这样一个过程：","keywords":["cpp"],"articleBody":"C++ 的类型可读性很差，并且大多数入门材料中并没有详细介绍如何阅读它们，最多只是讲到 top-level const 和 low-level const 的区别。有不少朋友问过我这方面的问题，讲得多了，干脆整理起来写篇文章。\n常见误解 在详细讲类型的阅读之前，需要纠正一个常见的误解。\n问：int a[5] 里的 a 是什么类型的？\n答：int[5] 类型，在适当的时候会「退化」（decay）成为 int* 类型。\n问：int a[5][6] 里的 a 是什么类型的？\n答：int[5][6] 类型，在适当的时候会「退化」成为 int(*)[6] 类型，即指向 int[6] 的指针。\n由于「退化」这种隐式转换的存在，很多初学 C++ 的人会把数组类型等同于指针类型。\n类似的，函数类型也会「退化」到指针类型，如 int(int, int) 会「退化」成为 int(*)(int, int)。\n解方程 当你查阅如何阅读一些复杂的类型时，你可能会看到网络上一些人说 C++ 的类型就是解方程，让我来详细解释一下这句话。\n抛去 CVR (const, volatile, reference) 等不谈，C++ 最基本的声明分为两个部分：写在最左边的类型名是「类型说明符」（type specifier），剩下的部分是「声明符」（declarator）。这部分内容是从 C 继承过来的，它们是 C++ 类型里最恶心的地方。但这两个名字实在没啥识别度，我喜欢不严谨地称呼为返回值类型和调用表达式，这点后面会解释。先来看几个例子吧：\n声明 类型说明符 声明符 int a int a int* a int *a int a[5] int a[5] int* a[5] int *a[5] int (*a)[5] int (*a)[5] 作出这种分别后，就可以理解上表中a的类型是怎样决定的了：以「声明符」的形式调用a后，得到的返回值类型为「类型说明符」。所谓的解方程就是这样一个过程：\n由 int *a[5] 得到 *a[5] 的类型是 int。 即对 a[5] 解引用得到 int ，推出 a[5] 的类型是 int*。 即对 a 取下标得到 int* ，推出 a 的类型是 5 个 int* 的数组。 再比如：\n由 int (*a)[5] 得到 (*a)[5] 的类型是 int。 即对 (*a) 取下标得到 int，推出 (*a) 的类型是 int[5]。 即对 a 解引用得到 int[5]，推出 a 的类型是指向 int[5] 的指针。 可以看到这里运算符优先级和调用时完全一致，形式上也基本一致。\n再来个函数指针的例子：\n由 int (*a)(int, int) 得到 (*a)(int, int) 的类型是 int。 即对 (*a) 以 (int, int) 的形式调用得到 int，推出 (*a) 的类型是有两个 int 参数并且返回 int 的函数，即 int(int, int)。 即对 a 解引用得到 int(int, int)，推出 a 的类型是指向 int(int, int) 的指针。 更复杂一点：\n由 int (*(Foo::*a[5])(int, int))(int) 得到 (*(Foo::*a[5])(int, int))(int) 的类型是 int。 推出 (*(Foo::*a[5])(int, int)) 的类型是 int(int)。 推出 (Foo::*a[5])(int, int) 的类型是指向 int(int) 的指针，即 int(*)(int)。 推出 (Foo::*a[5]) 的类型是有两个 int 参数并且返回 int(*)(int) 的函数。 推出 a[5] 的类型是指向这种函数的成员指针。 推出 a 的类型是 5 个这种成员指针的数组。 简而言之，你可以把「声明符」部分看成一个调用表达式，这个调用表达式的返回值类型为「类型说明符」，这样就可以一步步倒推出类型来。\n当然了，这么复杂的类型是不推荐这么写的，这里只是为了演示一下解方程的过程。上面那个a正常一点的声明大概会长这样：\nstruct Foo { auto bar(int, int) -\u003e int(*)(int); }; decltype(\u0026Foo::bar) a[5]; 即使在 C++11 以前，也可以利用 typedef 拆解成多层，提升可读性：\nstruct Foo { typedef int (*bar_t)(int); bar_t bar(int, int); }; typedef Foo::bar_t (Foo::*foo_bar_t)(int, int); foo_bar_t a[5]; 这种包装在 C 语言中还是挺常见的。\n不过如果你要看的类型是 demangle 出来的（或者其他查看类型名的方式），那就是长成那种魔鬼样子了。\n多变量声明 有了前面的知识，就能够理解 C++ 多变量声明的规则了。多变量声明中，逗号分割的是「声明符」（即调用表达式部分），它们共享「类型说明符」（即返回值部分），比如：\nint *a, b; 其中 a 的类型为 int* 而 b 的类型则为 int，因为 * 是「声明符」的一部分。如果你希望定义两个指针，那么应该写成 int *a, *b。\n更复杂的例子也遵循同样的规则。因为实在想不到更复杂的情况这样写有什么意义，就不再举例子了。\nconst 与 volatile const 与 volatile 在类型中的位置是一样的，并且他们两个可以一起使用，因此这里仅仅用 const 作为例子。下面出现的所有 const 都可以合法地替换成 volatile、const volatile 和 volatile const，后两者语义上等价。\nconst 在一般情况下都很明确，如 const int a 和 int (*a)(const std::string\u0026)。const 的理解障碍主要出在指针的情况中。对于指针来说，const 需要能表达两种含义：\n指针本身是 const 的，即这个指针没法再指向别的值，如 char *const a。 指针所指向的对象是 const 的，即你没法通过这个指针修改它指向的对象，如 const char* a。 当指针嵌套时，我们还要考虑指针指向的指针的 const 属性，于是类型就变得复杂起来。有了前面的知识，我们可以把 const 分为修饰「类型说明符」的 const 和修饰「声明符」的 const。看下面这个类型：\nconst int * const * * const a; 从左往右的第一个 const 为修饰「类型说明符」的 const，其余的为修饰「声明符」的 const。\n修饰「类型说明符」的 const 只要写在「类型说明符」旁边，不论 const T 还是 T const 都是合法且等价的。也就是上面这个例子还可以写成：\nint const * const * * const a; 它们都说明：\n* const * * const a（当然去掉 const 后它才是一个合法的表达式，下同）的类型为 const int（不能修改 ***a） 修饰「声明符」的 const 只要看解方程时解到哪个表达式，就说明修饰的是哪个表达式的类型。接着上面这个例子：\n推出 * * const a 是一个指向 const int 的 const 指针（不能修改 **a） 推出 * const a 是一个指向前面那个指针的非 const 指针（可以修改 *a） 推出 a 是一个指向前面那个指针的 const 指针（不能修改 a） 著名的 C++ 入门书籍《C++ Primer》把 const 分为了「顶层 const 」（top-level const）和「底层 const 」（low-level const）（此为原版翻译，显然并不准确）。顶层指的是修饰指针自身的，也就是类型中最内层的；底层指的是其余的。这两个术语在只讨论一层指针的时候才比较好用，当然这也是绝大多数情况。\n\u0026 与 \u0026\u0026 C++ 的引用是一种非常特殊的类型。由于 C++ 规定引用不一定占用内存，所以你既没法写出引用类型的数组（int\u0026 a[5]），也没法写出指向引用类型的指针（int\u0026* a），除此之外还有很多地方无法使用引用。我认为这是一个非常失败的设计，凭空增加了很多障碍。它明明只是一个「不可空指针」（non-nullable pointer）而已。右值引用也并没有什么特别，只是带有所有权转移语义的引用而已。\n总之，除了函数类型（以及嵌套了函数类型的类型）里 \u0026 和 \u0026\u0026 会出现在参数类型和返回值类型中，其他情况下 \u0026 和 \u0026\u0026 只会出现在类型的最顶层。这里的顶层的含义与前文的「顶层 const 」相同。\n\u0026 和 \u0026\u0026 没法直接嵌套使用，比如 int\u0026 \u0026\u0026 a 是非法的。但是间接嵌套是合法的，比如：\nusing ref1 = int\u0026\u0026; using ref2 = ref1\u0026\u0026; using ref3 = ref2\u0026; 在这种情况下会发生「引用折叠」（reference collapsing）。规则也很简单，如果全是 \u0026\u0026，那么会折叠成一个 \u0026\u0026。只要有一个 \u0026，就会折叠成 \u0026。比如上面的 ref2 实际上是 int\u0026\u0026，而 ref3 则是 int\u0026。\n\u0026\u0026 还有一种用法是在模板中。如果 T 是一个模板参数，那么 T\u0026\u0026（不能带有 const 和 volatile）就是一个「万能引用」（universal reference）。具体规则为：\n如果传入 T\u0026\u0026 的类型为 Foo\u0026，那么 T 就被推导为 Foo\u0026，而 T\u0026\u0026 经过折叠变成 Foo\u0026。 如果传入 T\u0026\u0026 的类型为 Foo\u0026\u0026，那么 T 就被推导为 Foo，而 T\u0026\u0026 则是 Foo\u0026\u0026。 请注意，T 被推导为什么类型这一点很重要，因为你可能在模板内部再次使用 T。\n成员函数 在 C++ 的成员函数中，我们有时会见到这样的例子：\nstruct Foo { int a(int, int) const; }; struct Bar { int a(int, int) \u0026\u0026; }; 这个其实也很好理解。C++ 的非 static 成员函数都可以调用 this，一个指向实例的指针。写在后面的 const 和 \u0026\u0026 就是用来修饰实例的。\n在其他一些语言（比如 Rust 和 Python ）中传入的实例是显式地作为第一个参数写出的，而 C++ 是隐式的（在 C++23 前），于是只能在其他地方加上类型修饰。不过即使不是隐式的，你也没法在 C++ 中直接写出 this 的类型，但这仍然是 C++ 的锅——因为 this 是一个指针，而 C++ 中指针没法指向引用类型。下面两个例子用注释不严谨地揭示了后置的类型修饰是怎么运作的：\nstruct Foo { // void a(const Foo\u0026 this_, int) { // const Foo* this = \u0026this_; // } void a(int) const\u0026; // void a(Foo\u0026\u0026 this_, int) { // Foo* this = \u0026this_; // } void a(int) \u0026\u0026; // void a(Foo\u0026 this_, int) { // Foo* this = \u0026this_; // } void a(int) \u0026; // foo.a(1) -\u003e Foo::a(foo, 1) }; struct Bar { // void a(const Bar\u0026 this_, int) { // const Bar* this = \u0026this_; // } // // or just: // // void a(const Bar* this, int); void a(int) const; // void a(Bar\u0026 this_, int) { // Bar* this = \u0026this_; // } // // or just: // // void a(Bar* this, int); void a(int); // bar.a(1) -\u003e Bar::a(bar, 1) // // or: // // bar.a(1) -\u003e Bar::a(\u0026bar, 1) }; 带有引用的成员函数无法和不带有引用的成员函数重载在一起，也就是你要么选择 Foo 演示的这一组，要么选择 Bar 演示的这一组。一些其他可能的重载，如带有 volatile 的，就不再写出了。\n从这个例子你也可以再一次看到 C++ 的引用设计得多么失败。\ntypedef 与 using 前文已经有 typedef 和 using 的例子了。typedef 的语法其实很简单，和定义变量是完全一致的。而 using 语法的区别仅仅在于把类型名的部分提到了左边。下面这个例子中，foo_t 和 bar_t 都和 func_ptr 的类型一致。\nint (*func_ptr)(int); typedef int (*foo_t)(int); using bar_t = int(*)(int); using 相比 typedef 的一个优势是可以直接定义「别名模板」（alias template），如：\ntemplate\u003ctypename T\u003e using foo_t = std::vector\u003cT\u003e; foo_t\u003cint\u003e foo; 在 C++11 以前，这种需求可以通过套一层 struct 或 class 实现，如：\ntemplate\u003ctypename T\u003e struct Bar { typedef std::vector\u003cT\u003e type; }; Bar\u003cint\u003e::type bar; 本文仅讨论类型，所以 using 的其他语义就略过了。\n更多 C++ 的声明语句构成部分相当复杂，并非只有「类型说明符」和「声明符」，但其余部分相比上文提到的那些已经相当人类友好了，没有多少学习障碍，而且其中的很多与类型无关。有兴趣了解的可以参阅 cppreference。\n类型本可以明确易读，只是 C 和 C++ 设计得很失败。既然读到这里了，那么恭喜你解决了一个其他语言不存在的问题。\n","wordCount":"734","inLanguage":"zh","datePublished":"2021-02-13T00:00:00Z","dateModified":"2021-02-13T00:00:00Z","author":{"@type":"Person","name":"QuarticCat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.quarticcat.com/zh/posts/read-cpp-types/"},"publisher":{"@type":"Organization","name":"QuarticCat's Blog","logo":{"@type":"ImageObject","url":"https://blog.quarticcat.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.quarticcat.com/zh/ accesskey=h title="Home (Alt + H)"><img src=https://blog.quarticcat.com/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.quarticcat.com/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://blog.quarticcat.com/zh/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.quarticcat.com/zh/tags/ title=标签><span>标签</span></a></li><li><a href=https://blog.quarticcat.com/zh/search/ title=搜索><span>搜索</span></a></li><li><a href=https://blog.quarticcat.com/zh/blogroll/ title=友链><span>友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">C++ 类型阅读入门</h1><div class=post-meta><span title='2021-02-13 00:00:00 +0000 UTC'>2021-02-13</span>&nbsp;·&nbsp;QuarticCat&nbsp;|&nbsp;语言:<ul class=i18n_list><li><a href=https://blog.quarticcat.com/posts/read-cpp-types/>En</a></li></ul></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#常见误解>常见误解</a></li><li><a href=#解方程>解方程</a></li><li><a href=#多变量声明>多变量声明</a></li><li><a href=#const-与-volatile><code>const</code> 与 <code>volatile</code></a></li><li><a href=#-与-><code>&</code> 与 <code>&&</code></a></li><li><a href=#成员函数>成员函数</a></li><li><a href=#typedef-与-using><code>typedef</code> 与 <code>using</code></a></li><li><a href=#更多>更多</a></li></ul></nav></div></details></div><div class=post-content><p>C++ 的类型可读性很差，并且大多数入门材料中并没有详细介绍如何阅读它们，最多只是讲到 top-level const 和 low-level const 的区别。有不少朋友问过我这方面的问题，讲得多了，干脆整理起来写篇文章。</p><h2 id=常见误解>常见误解<a hidden class=anchor aria-hidden=true href=#常见误解>#</a></h2><p>在详细讲类型的阅读之前，需要纠正一个常见的误解。</p><p>问：<code>int a[5]</code> 里的 <code>a</code> 是什么类型的？</p><p>答：<code>int[5]</code> 类型，在适当的时候会「退化」（decay）成为 <code>int*</code> 类型。</p><p>问：<code>int a[5][6]</code> 里的 <code>a</code> 是什么类型的？</p><p>答：<code>int[5][6]</code> 类型，在适当的时候会「退化」成为 <code>int(*)[6]</code> 类型，即指向 <code>int[6]</code> 的指针。</p><p>由于「退化」这种隐式转换的存在，很多初学 C++ 的人会把数组类型等同于指针类型。</p><p>类似的，函数类型也会「退化」到指针类型，如 <code>int(int, int)</code> 会「退化」成为 <code>int(*)(int, int)</code>。</p><h2 id=解方程>解方程<a hidden class=anchor aria-hidden=true href=#解方程>#</a></h2><p>当你查阅如何阅读一些复杂的类型时，你可能会看到网络上一些人说 C++ 的类型就是解方程，让我来详细解释一下这句话。</p><p>抛去 CVR (const, volatile, reference) 等不谈，C++ 最基本的声明分为两个部分：写在最左边的<strong>类型名</strong>是「类型说明符」（type specifier），剩下的部分是「声明符」（declarator）。这部分内容是从 C 继承过来的，它们是 C++ 类型里最恶心的地方。但这两个名字实在没啥识别度，我喜欢不严谨地称呼为返回值类型和调用表达式，这点后面会解释。先来看几个例子吧：</p><table><thead><tr><th style=text-align:center>声明</th><th style=text-align:center>类型说明符</th><th style=text-align:center>声明符</th></tr></thead><tbody><tr><td style=text-align:center><code>int a</code></td><td style=text-align:center><code>int</code></td><td style=text-align:center><code>a</code></td></tr><tr><td style=text-align:center><code>int* a</code></td><td style=text-align:center><code>int</code></td><td style=text-align:center><code>*a</code></td></tr><tr><td style=text-align:center><code>int a[5]</code></td><td style=text-align:center><code>int</code></td><td style=text-align:center><code>a[5]</code></td></tr><tr><td style=text-align:center><code>int* a[5]</code></td><td style=text-align:center><code>int</code></td><td style=text-align:center><code>*a[5]</code></td></tr><tr><td style=text-align:center><code>int (*a)[5]</code></td><td style=text-align:center><code>int</code></td><td style=text-align:center><code>(*a)[5]</code></td></tr></tbody></table><p>作出这种分别后，就可以理解上表中<code>a</code>的类型是怎样决定的了：<strong>以「声明符」的形式调用<code>a</code>后，得到的返回值类型为「类型说明符」</strong>。所谓的解方程就是这样一个过程：</p><ol><li>由 <code>int *a[5]</code> 得到 <code>*a[5]</code> 的类型是 <code>int</code>。</li><li>即对 <code>a[5]</code> 解引用得到 <code>int</code> ，推出 <code>a[5]</code> 的类型是 <code>int*</code>。</li><li>即对 <code>a</code> 取下标得到 <code>int*</code> ，推出 <code>a</code> 的类型是 5 个 <code>int*</code> 的数组。</li></ol><p>再比如：</p><ol><li>由 <code>int (*a)[5]</code> 得到 <code>(*a)[5]</code> 的类型是 <code>int</code>。</li><li>即对 <code>(*a)</code> 取下标得到 <code>int</code>，推出 <code>(*a)</code> 的类型是 <code>int[5]</code>。</li><li>即对 <code>a</code> 解引用得到 <code>int[5]</code>，推出 <code>a</code> 的类型是指向 <code>int[5]</code> 的指针。</li></ol><p>可以看到这里运算符优先级和调用时完全一致，形式上也基本一致。</p><p>再来个函数指针的例子：</p><ol><li>由 <code>int (*a)(int, int)</code> 得到 <code>(*a)(int, int)</code> 的类型是 <code>int</code>。</li><li>即对 <code>(*a)</code> 以 <code>(int, int)</code> 的形式调用得到 <code>int</code>，推出 <code>(*a)</code> 的类型是有两个 <code>int</code> 参数并且返回 <code>int</code> 的函数，即 <code>int(int, int)</code>。</li><li>即对 <code>a</code> 解引用得到 <code>int(int, int)</code>，推出 <code>a</code> 的类型是指向 <code>int(int, int)</code> 的指针。</li></ol><p>更复杂一点：</p><ol><li>由 <code>int (*(Foo::*a[5])(int, int))(int)</code> 得到 <code>(*(Foo::*a[5])(int, int))(int)</code> 的类型是 <code>int</code>。</li><li>推出 <code>(*(Foo::*a[5])(int, int))</code> 的类型是 <code>int(int)</code>。</li><li>推出 <code>(Foo::*a[5])(int, int)</code> 的类型是指向 <code>int(int)</code> 的指针，即 <code>int(*)(int)</code>。</li><li>推出 <code>(Foo::*a[5])</code> 的类型是有两个 <code>int</code> 参数并且返回 <code>int(*)(int)</code> 的函数。</li><li>推出 <code>a[5]</code> 的类型是指向这种函数的成员指针。</li><li>推出 <code>a</code> 的类型是 5 个这种成员指针的数组。</li></ol><p><strong>简而言之，你可以把「声明符」部分看成一个调用表达式，这个调用表达式的返回值类型为「类型说明符」，这样就可以一步步倒推出类型来。</strong></p><p>当然了，这么复杂的类型是不推荐这么写的，这里只是为了演示一下解方程的过程。上面那个<code>a</code>正常一点的声明大概会长这样：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Foo</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> <span style=color:#a6e22e>bar</span>(<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>int</span>(<span style=color:#f92672>*</span>)(<span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>decltype</span>(<span style=color:#f92672>&amp;</span>Foo<span style=color:#f92672>::</span>bar) a[<span style=color:#ae81ff>5</span>];
</span></span></code></pre></div><p>即使在 C++11 以前，也可以利用 <code>typedef</code> 拆解成多层，提升可读性：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Foo</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>int</span> (<span style=color:#f92672>*</span>bar_t)(<span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span>    bar_t <span style=color:#a6e22e>bar</span>(<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> Foo<span style=color:#f92672>::</span>bar_t (Foo<span style=color:#f92672>::*</span>foo_bar_t)(<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span>foo_bar_t a[<span style=color:#ae81ff>5</span>];
</span></span></code></pre></div><p>这种包装在 C 语言中还是挺常见的。</p><p>不过如果你要看的类型是 demangle 出来的（或者其他查看类型名的方式），那就是长成那种魔鬼样子了。</p><h2 id=多变量声明>多变量声明<a hidden class=anchor aria-hidden=true href=#多变量声明>#</a></h2><p>有了前面的知识，就能够理解 C++ 多变量声明的规则了。多变量声明中，逗号分割的是「声明符」（即调用表达式部分），它们共享「类型说明符」（即返回值部分），比如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>a, b;
</span></span></code></pre></div><p>其中 <code>a</code> 的类型为 <code>int*</code> 而 <code>b</code> 的类型则为 <code>int</code>，因为 <code>*</code> 是「声明符」的一部分。如果你希望定义两个指针，那么应该写成 <code>int *a, *b</code>。</p><p>更复杂的例子也遵循同样的规则。因为实在想不到更复杂的情况这样写有什么意义，就不再举例子了。</p><h2 id=const-与-volatile><code>const</code> 与 <code>volatile</code><a hidden class=anchor aria-hidden=true href=#const-与-volatile>#</a></h2><p><code>const</code> 与 <code>volatile</code> 在类型中的位置是一样的，并且他们两个可以一起使用，因此这里仅仅用 <code>const</code> 作为例子。下面出现的所有 <code>const</code> 都可以合法地替换成 <code>volatile</code>、<code>const volatile</code> 和 <code>volatile const</code>，后两者语义上等价。</p><p><code>const</code> 在一般情况下都很明确，如 <code>const int a</code> 和 <code>int (*a)(const std::string&)</code>。<code>const</code> 的理解障碍主要出在指针的情况中。对于指针来说，<code>const</code> 需要能表达两种含义：</p><ol><li>指针本身是 <code>const</code> 的，即这个指针没法再指向别的值，如 <code>char *const a</code>。</li><li>指针所指向的对象是 <code>const</code> 的，即你没法通过这个指针修改它指向的对象，如 <code>const char* a</code>。</li></ol><p>当指针嵌套时，我们还要考虑指针指向的指针的 <code>const</code> 属性，于是类型就变得复杂起来。有了前面的知识，我们可以把 <code>const</code> 分为修饰「类型说明符」的 <code>const</code> 和修饰「声明符」的 <code>const</code>。看下面这个类型：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>const</span> a;
</span></span></code></pre></div><p>从左往右的第一个 <code>const</code> 为修饰「类型说明符」的 <code>const</code>，其余的为修饰「声明符」的 <code>const</code>。</p><p>修饰「类型说明符」的 <code>const</code> 只要写在「类型说明符」旁边，不论 <code>const T</code> 还是 <code>T const</code> 都是合法且等价的。也就是上面这个例子还可以写成：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>const</span> a;
</span></span></code></pre></div><p>它们都说明：</p><ol><li><code>* const * * const a</code>（当然去掉 <code>const</code> 后它才是一个合法的表达式，下同）的类型为 <code>const int</code>（不能修改 <code>***a</code>）</li></ol><p>修饰「声明符」的 <code>const</code> 只要看解方程时解到哪个表达式，就说明修饰的是哪个表达式的类型。接着上面这个例子：</p><ol start=2><li>推出 <code>* * const a</code> 是一个指向 <code>const int</code> 的 const 指针（不能修改 <code>**a</code>）</li><li>推出 <code>* const a</code> 是一个指向前面那个指针的非 const 指针（可以修改 <code>*a</code>）</li><li>推出 <code>a</code> 是一个指向前面那个指针的 const 指针（不能修改 <code>a</code>）</li></ol><p>著名的 C++ 入门书籍《C++ Primer》把 <code>const</code> 分为了「顶层 const 」（top-level const）和「底层 const 」（low-level const）（此为原版翻译，显然并不准确）。顶层指的是修饰指针自身的，也就是类型中最内层的；底层指的是其余的。这两个术语在只讨论一层指针的时候才比较好用，当然这也是绝大多数情况。</p><h2 id=-与-><code>&</code> 与 <code>&&</code><a hidden class=anchor aria-hidden=true href=#-与->#</a></h2><p>C++ 的引用是一种非常特殊的类型。由于 C++ 规定引用不一定占用内存，所以你既没法写出引用类型的数组（<code>int& a[5]</code>），也没法写出指向引用类型的指针（<code>int&* a</code>），除此之外还有很多地方无法使用引用。我认为这是一个非常失败的设计，凭空增加了很多障碍。它明明只是一个「不可空指针」（non-nullable pointer）而已。右值引用也并没有什么特别，只是带有所有权转移语义的引用而已。</p><p>总之，除了函数类型（以及嵌套了函数类型的类型）里 <code>&</code> 和 <code>&&</code> 会出现在参数类型和返回值类型中，其他情况下 <code>&</code> 和 <code>&&</code> 只会出现在类型的最顶层。这里的顶层的含义与前文的「顶层 const 」相同。</p><p><code>&</code> 和 <code>&&</code> 没法直接嵌套使用，比如 <code>int& && a</code> 是非法的。但是间接嵌套是合法的，比如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>using</span> ref1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;&amp;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> ref2 <span style=color:#f92672>=</span> ref1<span style=color:#f92672>&amp;&amp;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> ref3 <span style=color:#f92672>=</span> ref2<span style=color:#f92672>&amp;</span>;
</span></span></code></pre></div><p>在这种情况下会发生「引用折叠」（reference collapsing）。规则也很简单，如果全是 <code>&&</code>，那么会折叠成一个 <code>&&</code>。只要有一个 <code>&</code>，就会折叠成 <code>&</code>。比如上面的 <code>ref2</code> 实际上是 <code>int&&</code>，而 <code>ref3</code> 则是 <code>int&</code>。</p><p><code>&&</code> 还有一种用法是在模板中。如果 <code>T</code> 是一个模板参数，那么 <code>T&&</code>（不能带有 <code>const</code> 和 <code>volatile</code>）就是一个「万能引用」（universal reference）。具体规则为：</p><ol><li>如果传入 <code>T&&</code> 的类型为 <code>Foo&</code>，那么 <code>T</code> 就被推导为 <code>Foo&</code>，而 <code>T&&</code> 经过折叠变成 <code>Foo&</code>。</li><li>如果传入 <code>T&&</code> 的类型为 <code>Foo&&</code>，那么 <code>T</code> 就被推导为 <code>Foo</code>，而 <code>T&&</code> 则是 <code>Foo&&</code>。</li></ol><p>请注意，<code>T</code> 被推导为什么类型这一点很重要，因为你可能在模板内部再次使用 <code>T</code>。</p><h2 id=成员函数>成员函数<a hidden class=anchor aria-hidden=true href=#成员函数>#</a></h2><p>在 C++ 的成员函数中，我们有时会见到这样的例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Foo</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>a</span>(<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Bar</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>a</span>(<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>) <span style=color:#f92672>&amp;&amp;</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>这个其实也很好理解。C++ 的非 static 成员函数都可以调用 <code>this</code>，一个指向实例的指针。写在后面的 <code>const</code> 和 <code>&&</code> 就是用来修饰实例的。</p><p>在其他一些语言（比如 Rust 和 Python ）中传入的实例是显式地作为第一个参数写出的，而 C++ 是隐式的（在 C++23 前），于是只能在其他地方加上类型修饰。不过即使不是隐式的，你也没法在 C++ 中直接写出 <code>this</code> 的类型，但这仍然是 C++ 的锅——因为 <code>this</code> 是一个指针，而 C++ 中指针没法指向引用类型。下面两个例子用注释不严谨地揭示了后置的类型修饰是怎么运作的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Foo</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// void a(const Foo&amp; this_, int) {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//     const Foo* this = &amp;this_;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>a</span>(<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>const</span><span style=color:#f92672>&amp;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// void a(Foo&amp;&amp; this_, int) {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//     Foo* this = &amp;this_;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>a</span>(<span style=color:#66d9ef>int</span>) <span style=color:#f92672>&amp;&amp;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// void a(Foo&amp; this_, int) {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//     Foo* this = &amp;this_;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>a</span>(<span style=color:#66d9ef>int</span>) <span style=color:#f92672>&amp;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// foo.a(1) -&gt; Foo::a(foo, 1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Bar</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// void a(const Bar&amp; this_, int) {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//     const Bar* this = &amp;this_;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// or just:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// void a(const Bar* this, int);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>a</span>(<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// void a(Bar&amp; this_, int) {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//     Bar* this = &amp;this_;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// or just:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// void a(Bar* this, int);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>a</span>(<span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// bar.a(1) -&gt; Bar::a(bar, 1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// or:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// bar.a(1) -&gt; Bar::a(&amp;bar, 1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><p>带有引用的成员函数无法和不带有引用的成员函数重载在一起，也就是你要么选择 <code>Foo</code> 演示的这一组，要么选择 <code>Bar</code> 演示的这一组。一些其他可能的重载，如带有 <code>volatile</code> 的，就不再写出了。</p><p>从这个例子你也可以再一次看到 C++ 的引用设计得多么失败。</p><h2 id=typedef-与-using><code>typedef</code> 与 <code>using</code><a hidden class=anchor aria-hidden=true href=#typedef-与-using>#</a></h2><p>前文已经有 <code>typedef</code> 和 <code>using</code> 的例子了。<code>typedef</code> 的语法其实很简单，和定义变量是完全一致的。而 <code>using</code> 语法的区别仅仅在于<strong>把类型名的部分提到了左边</strong>。下面这个例子中，<code>foo_t</code> 和 <code>bar_t</code> 都和 <code>func_ptr</code> 的类型一致。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> (<span style=color:#f92672>*</span>func_ptr)(<span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>int</span> (<span style=color:#f92672>*</span>foo_t)(<span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> bar_t <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span>(<span style=color:#f92672>*</span>)(<span style=color:#66d9ef>int</span>);
</span></span></code></pre></div><p><code>using</code> 相比 <code>typedef</code> 的一个优势是可以直接定义「别名模板」（alias template），如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> foo_t <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>foo_t<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> foo;
</span></span></code></pre></div><p>在 C++11 以前，这种需求可以通过套一层 <code>struct</code> 或 <code>class</code> 实现，如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Bar</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>typedef</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> type;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Bar<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;::</span>type bar;
</span></span></code></pre></div><p>本文仅讨论类型，所以 <code>using</code> 的其他语义就略过了。</p><h2 id=更多>更多<a hidden class=anchor aria-hidden=true href=#更多>#</a></h2><p>C++ 的声明语句构成部分相当复杂，并非只有「类型说明符」和「声明符」，但其余部分相比上文提到的那些已经相当人类友好了，没有多少学习障碍，而且其中的很多与类型无关。有兴趣了解的可以参阅 <a href=https://zh.cppreference.com/w/cpp/language/declarations>cppreference</a>。</p><p>类型本可以明确易读，只是 C 和 C++ 设计得很失败。既然读到这里了，那么恭喜你解决了一个其他语言不存在的问题。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.quarticcat.com/zh/tags/cpp/>Cpp</a></li></ul><nav class=paginav><a class=prev href=https://blog.quarticcat.com/zh/posts/cpp-ctti/><span class=title>« 上一页</span><br><span>C++：编译期类型信息</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.quarticcat.com/zh/>QuarticCat's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>