<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++：异质查找（heterogeneous lookup） | QuarticCat's Blog</title>
<meta name=keywords content="cpp"><meta name=description content="太久没更新博文了，水一篇凑数
从 String View 说起 C 风格的字符串常常需要自己记录长度、管理生命周期，涉及长度变化时更是比较麻烦。于是在 C++ 中我们有了 std::string，并且有了与之配套的一系列函数，比如 std::stoi，对应 C 里面的 atoi。这个函数的声明如下：
int stoi(const std::string& str, std::size_t* pos = 0, int base = 10); 这个接口接受一个 const std::string&，乍看或许是理所应当的：我是 C++ 函数，我需要读取字符串，但是我不需要修改它。实际上，C++ 中有很多接受 const std::string& 的函数，然而很遗憾，这个设计是失败的。
考虑这样一种情况，我们需要读取一个 std::string 里的子串，但我们不需要修改它。比如对一个拥有很多数字的字符串进行连续 parse ，或者在某个大文本里找到某个模板再对匹配结果进行进一步筛选。这种情况下，这些接受 const std::string& 的函数就变得不好用了，因为子串不是一个 std::string 对象。我们往往不得不把子串复制到一个新的 std::string 对象里，造成了额外的开销。
类似的常见情况还有，我们接收到了一个 C 风格的字符串，以 char* str + size_t len 的形式，而我们希望能在这个字符串上使用各种 C++ 函数的功能。比如跟 C 接口交互的时候，或者用 buffer 从别的地方接收字符串数据的时候。
所以要怎么解决呢？我们可以采用 C 风格的接口，即 char* str + size_t len，或者采用迭代器风格的接口，即 char* begin + char* end。而将这两个参数合起来，我们就得到了 std::string_view ——只读字符串接口的正确答案。它不仅比 const std::string& 更泛用，而且在没有发生 SSO 的情况下，它还比 const std::string& 减少了一次指针跳转。"><meta name=author content="QuarticCat"><link rel=canonical href=https://blog.quarticcat.com/zh/posts/cpp-heterogeneous-lookup/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.quarticcat.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.quarticcat.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.quarticcat.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.quarticcat.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.quarticcat.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://blog.quarticcat.com/zh/posts/cpp-heterogeneous-lookup/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "f4a0d5ded0bc48e19ea90f852a11cb57"}'></script><meta property="og:title" content="C++：异质查找（heterogeneous lookup）"><meta property="og:description" content="太久没更新博文了，水一篇凑数
从 String View 说起 C 风格的字符串常常需要自己记录长度、管理生命周期，涉及长度变化时更是比较麻烦。于是在 C++ 中我们有了 std::string，并且有了与之配套的一系列函数，比如 std::stoi，对应 C 里面的 atoi。这个函数的声明如下：
int stoi(const std::string& str, std::size_t* pos = 0, int base = 10); 这个接口接受一个 const std::string&，乍看或许是理所应当的：我是 C++ 函数，我需要读取字符串，但是我不需要修改它。实际上，C++ 中有很多接受 const std::string& 的函数，然而很遗憾，这个设计是失败的。
考虑这样一种情况，我们需要读取一个 std::string 里的子串，但我们不需要修改它。比如对一个拥有很多数字的字符串进行连续 parse ，或者在某个大文本里找到某个模板再对匹配结果进行进一步筛选。这种情况下，这些接受 const std::string& 的函数就变得不好用了，因为子串不是一个 std::string 对象。我们往往不得不把子串复制到一个新的 std::string 对象里，造成了额外的开销。
类似的常见情况还有，我们接收到了一个 C 风格的字符串，以 char* str + size_t len 的形式，而我们希望能在这个字符串上使用各种 C++ 函数的功能。比如跟 C 接口交互的时候，或者用 buffer 从别的地方接收字符串数据的时候。
所以要怎么解决呢？我们可以采用 C 风格的接口，即 char* str + size_t len，或者采用迭代器风格的接口，即 char* begin + char* end。而将这两个参数合起来，我们就得到了 std::string_view ——只读字符串接口的正确答案。它不仅比 const std::string& 更泛用，而且在没有发生 SSO 的情况下，它还比 const std::string& 减少了一次指针跳转。"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.quarticcat.com/zh/posts/cpp-heterogeneous-lookup/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-10-16T00:00:00+00:00"><meta property="article:modified_time" content="2021-10-16T00:00:00+00:00"><meta property="og:site_name" content="QuarticCat's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++：异质查找（heterogeneous lookup）"><meta name=twitter:description content="太久没更新博文了，水一篇凑数
从 String View 说起 C 风格的字符串常常需要自己记录长度、管理生命周期，涉及长度变化时更是比较麻烦。于是在 C++ 中我们有了 std::string，并且有了与之配套的一系列函数，比如 std::stoi，对应 C 里面的 atoi。这个函数的声明如下：
int stoi(const std::string& str, std::size_t* pos = 0, int base = 10); 这个接口接受一个 const std::string&，乍看或许是理所应当的：我是 C++ 函数，我需要读取字符串，但是我不需要修改它。实际上，C++ 中有很多接受 const std::string& 的函数，然而很遗憾，这个设计是失败的。
考虑这样一种情况，我们需要读取一个 std::string 里的子串，但我们不需要修改它。比如对一个拥有很多数字的字符串进行连续 parse ，或者在某个大文本里找到某个模板再对匹配结果进行进一步筛选。这种情况下，这些接受 const std::string& 的函数就变得不好用了，因为子串不是一个 std::string 对象。我们往往不得不把子串复制到一个新的 std::string 对象里，造成了额外的开销。
类似的常见情况还有，我们接收到了一个 C 风格的字符串，以 char* str + size_t len 的形式，而我们希望能在这个字符串上使用各种 C++ 函数的功能。比如跟 C 接口交互的时候，或者用 buffer 从别的地方接收字符串数据的时候。
所以要怎么解决呢？我们可以采用 C 风格的接口，即 char* str + size_t len，或者采用迭代器风格的接口，即 char* begin + char* end。而将这两个参数合起来，我们就得到了 std::string_view ——只读字符串接口的正确答案。它不仅比 const std::string& 更泛用，而且在没有发生 SSO 的情况下，它还比 const std::string& 减少了一次指针跳转。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.quarticcat.com/zh/posts/"},{"@type":"ListItem","position":2,"name":"C++：异质查找（heterogeneous lookup）","item":"https://blog.quarticcat.com/zh/posts/cpp-heterogeneous-lookup/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++：异质查找（heterogeneous lookup）","name":"C\u002b\u002b：异质查找（heterogeneous lookup）","description":"太久没更新博文了，水一篇凑数\n从 String View 说起 C 风格的字符串常常需要自己记录长度、管理生命周期，涉及长度变化时更是比较麻烦。于是在 C++ 中我们有了 std::string，并且有了与之配套的一系列函数，比如 std::stoi，对应 C 里面的 atoi。这个函数的声明如下：\nint stoi(const std::string\u0026amp; str, std::size_t* pos = 0, int base = 10); 这个接口接受一个 const std::string\u0026amp;，乍看或许是理所应当的：我是 C++ 函数，我需要读取字符串，但是我不需要修改它。实际上，C++ 中有很多接受 const std::string\u0026amp; 的函数，然而很遗憾，这个设计是失败的。\n考虑这样一种情况，我们需要读取一个 std::string 里的子串，但我们不需要修改它。比如对一个拥有很多数字的字符串进行连续 parse ，或者在某个大文本里找到某个模板再对匹配结果进行进一步筛选。这种情况下，这些接受 const std::string\u0026amp; 的函数就变得不好用了，因为子串不是一个 std::string 对象。我们往往不得不把子串复制到一个新的 std::string 对象里，造成了额外的开销。\n类似的常见情况还有，我们接收到了一个 C 风格的字符串，以 char* str + size_t len 的形式，而我们希望能在这个字符串上使用各种 C++ 函数的功能。比如跟 C 接口交互的时候，或者用 buffer 从别的地方接收字符串数据的时候。\n所以要怎么解决呢？我们可以采用 C 风格的接口，即 char* str + size_t len，或者采用迭代器风格的接口，即 char* begin + char* end。而将这两个参数合起来，我们就得到了 std::string_view ——只读字符串接口的正确答案。它不仅比 const std::string\u0026amp; 更泛用，而且在没有发生 SSO 的情况下，它还比 const std::string\u0026amp; 减少了一次指针跳转。","keywords":["cpp"],"articleBody":"太久没更新博文了，水一篇凑数\n从 String View 说起 C 风格的字符串常常需要自己记录长度、管理生命周期，涉及长度变化时更是比较麻烦。于是在 C++ 中我们有了 std::string，并且有了与之配套的一系列函数，比如 std::stoi，对应 C 里面的 atoi。这个函数的声明如下：\nint stoi(const std::string\u0026 str, std::size_t* pos = 0, int base = 10); 这个接口接受一个 const std::string\u0026，乍看或许是理所应当的：我是 C++ 函数，我需要读取字符串，但是我不需要修改它。实际上，C++ 中有很多接受 const std::string\u0026 的函数，然而很遗憾，这个设计是失败的。\n考虑这样一种情况，我们需要读取一个 std::string 里的子串，但我们不需要修改它。比如对一个拥有很多数字的字符串进行连续 parse ，或者在某个大文本里找到某个模板再对匹配结果进行进一步筛选。这种情况下，这些接受 const std::string\u0026 的函数就变得不好用了，因为子串不是一个 std::string 对象。我们往往不得不把子串复制到一个新的 std::string 对象里，造成了额外的开销。\n类似的常见情况还有，我们接收到了一个 C 风格的字符串，以 char* str + size_t len 的形式，而我们希望能在这个字符串上使用各种 C++ 函数的功能。比如跟 C 接口交互的时候，或者用 buffer 从别的地方接收字符串数据的时候。\n所以要怎么解决呢？我们可以采用 C 风格的接口，即 char* str + size_t len，或者采用迭代器风格的接口，即 char* begin + char* end。而将这两个参数合起来，我们就得到了 std::string_view ——只读字符串接口的正确答案。它不仅比 const std::string\u0026 更泛用，而且在没有发生 SSO 的情况下，它还比 const std::string\u0026 减少了一次指针跳转。\nRust 很早就想明白了这个问题，一开始就提供了 String（对应 C++ 的 string）和 \u0026str（对应 C++ 的 string_view），并且在各个接口上统一了用法。而 C++ 则是群魔乱舞，什么样的接口都有。\n泛型的困境 假设你现在在写一个泛型容器 map，你要给他添加一个 .find 成员来进行查找。那么 .find 的参数应该是什么呢？一般来说 const K\u0026 就可以了，但要是 K = std::string，那么就会遇到前面所说的问题了。给 std::string 做一个特化吗？不，我们要考虑更一般的问题，即如何在泛型里处理一个类型有多种表示的情况。我们应该允许 .find 的参数是其他一些和 K 有关系的类型。C++ 的异质查找（heterogeneous lookup）说的就是这么样一种操作，异质在这里指的是存储的类型和查询的类型不一样。\n要解决这个问题也并不是很困难。在 std::map 等容器中原本就有一个 Compare 泛型参数用于设置比较器，我们只要接收一个可以比较不同类型的比较器并且把 .find 的参数放宽到任意类型就可以了。\n默认情况下，Compare 的值是 std::less，其 operator() 函数只能用于 Key 和 Key 的比较。在 C++14 后，std::less 等函数新增加了 void 特化，其 operator() 函数是一个模板，接受任意类型并返回 std::forward(lhs) \u003c std::forward(rhs) 。我们只要将 std::map 的 Compare 参数设置成 std::less\u003c\u003e 即可使用异质查找。\nusing namespace std::literals::string_view_literals; std::map\u003cstd::string, int, std::less\u003c\u003e\u003e foo; foo.find(\"key\"sv); 或者你也可以定制自己的比较器，只要它有个合法的成员类型 is_transparent，也会启用异质查找。\n以上是对 std::map 和 std::set 而言的。对于 unordered 系列容器，则是要求 Hash::is_transparent 和 KeyEqual::is_transparent。另外 unordered 系列容器的异质查找在 C++20 才被加入。\nRust 里的解决方案则是用一个 Borrow trait 来描述这种关系，相对来说约束更大一些。有兴趣的可以自行阅读文档，这里就不展开讲了。\n很遗憾 C++ 太晚意识到这些问题了，导致留下了大量的失败设计。为了兼容性考虑，异质查找不能默认启用，这导致启用了异质查找的和不启用的两个 std::map 类型是不一样的。所以即使这项功能已经可用，你也可能受限于旧有接口。\n","wordCount":"186","inLanguage":"zh","datePublished":"2021-10-16T00:00:00Z","dateModified":"2021-10-16T00:00:00Z","author":{"@type":"Person","name":"QuarticCat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.quarticcat.com/zh/posts/cpp-heterogeneous-lookup/"},"publisher":{"@type":"Organization","name":"QuarticCat's Blog","logo":{"@type":"ImageObject","url":"https://blog.quarticcat.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.quarticcat.com/zh/ accesskey=h title="Home (Alt + H)"><img src=https://blog.quarticcat.com/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.quarticcat.com/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://blog.quarticcat.com/zh/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.quarticcat.com/zh/tags/ title=标签><span>标签</span></a></li><li><a href=https://blog.quarticcat.com/zh/search/ title=搜索><span>搜索</span></a></li><li><a href=https://blog.quarticcat.com/zh/blogroll/ title=友链><span>友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">C++：异质查找（heterogeneous lookup）</h1><div class=post-meta><span title='2021-10-16 00:00:00 +0000 UTC'>2021-10-16</span>&nbsp;·&nbsp;QuarticCat</div></header><div class=post-content><p><del>太久没更新博文了，水一篇凑数</del></p><h2 id=从-string-view-说起>从 String View 说起<a hidden class=anchor aria-hidden=true href=#从-string-view-说起>#</a></h2><p>C 风格的字符串常常需要自己记录长度、管理生命周期，涉及长度变化时更是比较麻烦。于是在 C++ 中我们有了 <code>std::string</code>，并且有了与之配套的一系列函数，比如 <code>std::stoi</code>，对应 C 里面的 <code>atoi</code>。这个函数的声明如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>stoi</span>(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> str, std<span style=color:#f92672>::</span>size_t<span style=color:#f92672>*</span> pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>int</span> base <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>);
</span></span></code></pre></div><p>这个接口接受一个 <code>const std::string&</code>，乍看或许是理所应当的：我是 C++ 函数，我需要读取字符串，但是我不需要修改它。实际上，C++ 中有很多接受 <code>const std::string&</code> 的函数，然而很遗憾，这个设计是失败的。</p><p>考虑这样一种情况，我们需要读取一个 <code>std::string</code> 里的子串，但我们不需要修改它。比如对一个拥有很多数字的字符串进行连续 parse ，或者在某个大文本里找到某个模板再对匹配结果进行进一步筛选。这种情况下，这些接受 <code>const std::string&</code> 的函数就变得不好用了，因为子串不是一个 <code>std::string</code> 对象。我们往往不得不把子串复制到一个新的 <code>std::string</code> 对象里，造成了额外的开销。</p><p>类似的常见情况还有，我们接收到了一个 C 风格的字符串，以 <code>char* str</code> + <code>size_t len</code> 的形式，而我们希望能在这个字符串上使用各种 C++ 函数的功能。比如跟 C 接口交互的时候，或者用 buffer 从别的地方接收字符串数据的时候。</p><p>所以要怎么解决呢？我们可以采用 C 风格的接口，即 <code>char* str</code> + <code>size_t len</code>，或者采用迭代器风格的接口，即 <code>char* begin</code> + <code>char* end</code>。而将这两个参数合起来，我们就得到了 <code>std::string_view</code> ——只读字符串接口的正确答案。它不仅比 <code>const std::string&</code> 更泛用，而且在没有发生 SSO 的情况下，它还比 <code>const std::string&</code> 减少了一次指针跳转。</p><p>Rust 很早就想明白了这个问题，一开始就提供了 <code>String</code>（对应 C++ 的 <code>string</code>）和 <code>&amp;str</code>（对应 C++ 的 <code>string_view</code>），并且在各个接口上统一了用法。而 C++ 则是群魔乱舞，什么样的接口都有。</p><h2 id=泛型的困境>泛型的困境<a hidden class=anchor aria-hidden=true href=#泛型的困境>#</a></h2><p>假设你现在在写一个泛型容器 <code>map&lt;K, V></code>，你要给他添加一个 <code>.find</code> 成员来进行查找。那么 <code>.find</code> 的参数应该是什么呢？一般来说 <code>const K&</code> 就可以了，但要是 <code>K = std::string</code>，那么就会遇到前面所说的问题了。给 <code>std::string</code> 做一个特化吗？不，我们要考虑更一般的问题，即<strong>如何在泛型里处理一个类型有多种表示的情况</strong>。我们应该允许 <code>.find</code> 的参数是其他一些和 <code>K</code> 有关系的类型。C++ 的异质查找（heterogeneous lookup）说的就是这么样一种操作，异质在这里指的是存储的类型和查询的类型不一样。</p><p>要解决这个问题也并不是很困难。在 <code>std::map</code> 等容器中原本就有一个 <code>Compare</code> 泛型参数用于设置比较器，我们只要接收一个可以比较不同类型的比较器并且把 <code>.find</code> 的参数放宽到任意类型就可以了。</p><p>默认情况下，<code>Compare</code> 的值是 <code>std::less&lt;Key></code>，其 <code>operator()</code> 函数只能用于 <code>Key</code> 和 <code>Key</code> 的比较。在 C++14 后，<code>std::less</code> 等函数新增加了 <code>void</code> 特化，其 <code>operator()</code> 函数是一个模板，接受任意类型并返回 <code>std::forward&lt;T>(lhs) &lt; std::forward&lt;U>(rhs)</code> 。我们只要将 <code>std::map</code> 的 <code>Compare</code> 参数设置成 <code>std::less&lt;></code> 即可使用异质查找。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std<span style=color:#f92672>::</span>literals<span style=color:#f92672>::</span>string_view_literals;
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>map<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string, <span style=color:#66d9ef>int</span>, std<span style=color:#f92672>::</span>less<span style=color:#f92672>&lt;&gt;&gt;</span> foo;
</span></span><span style=display:flex><span>foo.find(<span style=color:#e6db74>&#34;key&#34;</span>sv);
</span></span></code></pre></div><p>或者你也可以定制自己的比较器，只要它有个合法的成员类型 <code>is_transparent</code>，也会启用异质查找。</p><p>以上是对 <code>std::map</code> 和 <code>std::set</code> 而言的。对于 unordered 系列容器，则是要求 <code>Hash::is_transparent</code> 和 <code>KeyEqual::is_transparent</code>。另外 unordered 系列容器的异质查找在 C++20 才被加入。</p><p>Rust 里的解决方案则是用一个 <code>Borrow</code> trait 来描述这种关系，相对来说约束更大一些。有兴趣的可以自行阅读<a href=https://doc.rust-lang.org/std/borrow/trait.Borrow.html>文档</a>，这里就不展开讲了。</p><p>很遗憾 C++ 太晚意识到这些问题了，导致留下了大量的失败设计。为了兼容性考虑，异质查找不能默认启用，这导致启用了异质查找的和不启用的两个 <code>std::map</code> 类型是不一样的。所以即使这项功能已经可用，你也可能受限于旧有接口。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.quarticcat.com/zh/tags/cpp/>Cpp</a></li></ul><nav class=paginav><a class=next href=https://blog.quarticcat.com/zh/posts/one-more-nasty-design-of-cpp-name-lookup/><span class=title>下一页 »</span><br><span>C++ 名称查找的又一个恶心设计</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.quarticcat.com/zh/>QuarticCat's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>