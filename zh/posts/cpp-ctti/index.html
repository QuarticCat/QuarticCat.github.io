<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++：编译期类型信息 | QuarticCat's Blog</title>
<meta name=keywords content="cpp"><meta name=description content="引言 尽管标准库中已经有了 typeid 运算符，但是由于其需要支持检查多态类型，带来了非常多的限制：
它必须启用 RTTI（Run-Time Type Information）。而很多项目是禁用 RTTI 的，所以无法使用 typeid。 它可能对表达式进行求值，详见 cppreference 。这可能带来意外的运行时开销甚至副作用，尤其是常用的 sizeof 和 decltype 都是完全静态的，不熟悉 typeid 的程序员可能完全意识不到这种动态行为的产生。 它不是 constexpr 的，即使其类型本可以静态求出。这意味着很多场景都无法使用 typeid，比如模板参数、switch-case 语句的 case 值等。 这就是我们为什么需要编译期类型信息，即 CTTI（Compile-Time Type Information）。
实现原理 C++ 标准中并没有提供相关的设施供我们实现这一功能。但通过 GCC 和 Clang 的一个特殊的预定义变量 __PRETTY_FUNCTION__，CTTI 得以实现。这个变量的值是当前函数完整签名的字符串。当在一个模板函数内部调用的时候，也会包含模板参数的类型名，这就达到了我们获取类型名字的目的。
注意，类似于标准中提供的 __func__，__PRETTY_FUNCTION__ 是一个变量，因此它没法被用来初始化字符数组或者跟字符串字面量拼接在一起。MSVC 没有 __PRETTY_FUNCTION__，但是有一个类似功能的宏 __FUNCSIG__，它被替换为一个字符串字面量。
template<typename T> constexpr std::string_view pretty_function() { return __PRETTY_FUNCTION__; } 在 Clang 上，调用 pretty_function<int>() 会返回 std::string_view pretty_function() [T = int]，可以看到 T 的类型正在其中。
请注意，这里的 typename T 不能直接省略成 typename，否则将不会出现 T 的类型名。"><meta name=author content="QuarticCat"><link rel=canonical href=https://blog.quarticcat.com/zh/posts/cpp-ctti/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.quarticcat.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.quarticcat.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.quarticcat.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.quarticcat.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.quarticcat.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://blog.quarticcat.com/zh/posts/cpp-ctti/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "f4a0d5ded0bc48e19ea90f852a11cb57"}'></script><meta property="og:title" content="C++：编译期类型信息"><meta property="og:description" content="引言 尽管标准库中已经有了 typeid 运算符，但是由于其需要支持检查多态类型，带来了非常多的限制：
它必须启用 RTTI（Run-Time Type Information）。而很多项目是禁用 RTTI 的，所以无法使用 typeid。 它可能对表达式进行求值，详见 cppreference 。这可能带来意外的运行时开销甚至副作用，尤其是常用的 sizeof 和 decltype 都是完全静态的，不熟悉 typeid 的程序员可能完全意识不到这种动态行为的产生。 它不是 constexpr 的，即使其类型本可以静态求出。这意味着很多场景都无法使用 typeid，比如模板参数、switch-case 语句的 case 值等。 这就是我们为什么需要编译期类型信息，即 CTTI（Compile-Time Type Information）。
实现原理 C++ 标准中并没有提供相关的设施供我们实现这一功能。但通过 GCC 和 Clang 的一个特殊的预定义变量 __PRETTY_FUNCTION__，CTTI 得以实现。这个变量的值是当前函数完整签名的字符串。当在一个模板函数内部调用的时候，也会包含模板参数的类型名，这就达到了我们获取类型名字的目的。
注意，类似于标准中提供的 __func__，__PRETTY_FUNCTION__ 是一个变量，因此它没法被用来初始化字符数组或者跟字符串字面量拼接在一起。MSVC 没有 __PRETTY_FUNCTION__，但是有一个类似功能的宏 __FUNCSIG__，它被替换为一个字符串字面量。
template<typename T> constexpr std::string_view pretty_function() { return __PRETTY_FUNCTION__; } 在 Clang 上，调用 pretty_function<int>() 会返回 std::string_view pretty_function() [T = int]，可以看到 T 的类型正在其中。
请注意，这里的 typename T 不能直接省略成 typename，否则将不会出现 T 的类型名。"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.quarticcat.com/zh/posts/cpp-ctti/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-02-14T00:00:00+00:00"><meta property="article:modified_time" content="2021-02-14T00:00:00+00:00"><meta property="og:site_name" content="QuarticCat's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++：编译期类型信息"><meta name=twitter:description content="引言 尽管标准库中已经有了 typeid 运算符，但是由于其需要支持检查多态类型，带来了非常多的限制：
它必须启用 RTTI（Run-Time Type Information）。而很多项目是禁用 RTTI 的，所以无法使用 typeid。 它可能对表达式进行求值，详见 cppreference 。这可能带来意外的运行时开销甚至副作用，尤其是常用的 sizeof 和 decltype 都是完全静态的，不熟悉 typeid 的程序员可能完全意识不到这种动态行为的产生。 它不是 constexpr 的，即使其类型本可以静态求出。这意味着很多场景都无法使用 typeid，比如模板参数、switch-case 语句的 case 值等。 这就是我们为什么需要编译期类型信息，即 CTTI（Compile-Time Type Information）。
实现原理 C++ 标准中并没有提供相关的设施供我们实现这一功能。但通过 GCC 和 Clang 的一个特殊的预定义变量 __PRETTY_FUNCTION__，CTTI 得以实现。这个变量的值是当前函数完整签名的字符串。当在一个模板函数内部调用的时候，也会包含模板参数的类型名，这就达到了我们获取类型名字的目的。
注意，类似于标准中提供的 __func__，__PRETTY_FUNCTION__ 是一个变量，因此它没法被用来初始化字符数组或者跟字符串字面量拼接在一起。MSVC 没有 __PRETTY_FUNCTION__，但是有一个类似功能的宏 __FUNCSIG__，它被替换为一个字符串字面量。
template<typename T> constexpr std::string_view pretty_function() { return __PRETTY_FUNCTION__; } 在 Clang 上，调用 pretty_function<int>() 会返回 std::string_view pretty_function() [T = int]，可以看到 T 的类型正在其中。
请注意，这里的 typename T 不能直接省略成 typename，否则将不会出现 T 的类型名。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.quarticcat.com/zh/posts/"},{"@type":"ListItem","position":2,"name":"C++：编译期类型信息","item":"https://blog.quarticcat.com/zh/posts/cpp-ctti/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++：编译期类型信息","name":"C\u002b\u002b：编译期类型信息","description":"引言 尽管标准库中已经有了 typeid 运算符，但是由于其需要支持检查多态类型，带来了非常多的限制：\n它必须启用 RTTI（Run-Time Type Information）。而很多项目是禁用 RTTI 的，所以无法使用 typeid。 它可能对表达式进行求值，详见 cppreference 。这可能带来意外的运行时开销甚至副作用，尤其是常用的 sizeof 和 decltype 都是完全静态的，不熟悉 typeid 的程序员可能完全意识不到这种动态行为的产生。 它不是 constexpr 的，即使其类型本可以静态求出。这意味着很多场景都无法使用 typeid，比如模板参数、switch-case 语句的 case 值等。 这就是我们为什么需要编译期类型信息，即 CTTI（Compile-Time Type Information）。\n实现原理 C++ 标准中并没有提供相关的设施供我们实现这一功能。但通过 GCC 和 Clang 的一个特殊的预定义变量 __PRETTY_FUNCTION__，CTTI 得以实现。这个变量的值是当前函数完整签名的字符串。当在一个模板函数内部调用的时候，也会包含模板参数的类型名，这就达到了我们获取类型名字的目的。\n注意，类似于标准中提供的 __func__，__PRETTY_FUNCTION__ 是一个变量，因此它没法被用来初始化字符数组或者跟字符串字面量拼接在一起。MSVC 没有 __PRETTY_FUNCTION__，但是有一个类似功能的宏 __FUNCSIG__，它被替换为一个字符串字面量。\ntemplate\u0026lt;typename T\u0026gt; constexpr std::string_view pretty_function() { return __PRETTY_FUNCTION__; } 在 Clang 上，调用 pretty_function\u0026lt;int\u0026gt;() 会返回 std::string_view pretty_function() [T = int]，可以看到 T 的类型正在其中。\n请注意，这里的 typename T 不能直接省略成 typename，否则将不会出现 T 的类型名。","keywords":["cpp"],"articleBody":"引言 尽管标准库中已经有了 typeid 运算符，但是由于其需要支持检查多态类型，带来了非常多的限制：\n它必须启用 RTTI（Run-Time Type Information）。而很多项目是禁用 RTTI 的，所以无法使用 typeid。 它可能对表达式进行求值，详见 cppreference 。这可能带来意外的运行时开销甚至副作用，尤其是常用的 sizeof 和 decltype 都是完全静态的，不熟悉 typeid 的程序员可能完全意识不到这种动态行为的产生。 它不是 constexpr 的，即使其类型本可以静态求出。这意味着很多场景都无法使用 typeid，比如模板参数、switch-case 语句的 case 值等。 这就是我们为什么需要编译期类型信息，即 CTTI（Compile-Time Type Information）。\n实现原理 C++ 标准中并没有提供相关的设施供我们实现这一功能。但通过 GCC 和 Clang 的一个特殊的预定义变量 __PRETTY_FUNCTION__，CTTI 得以实现。这个变量的值是当前函数完整签名的字符串。当在一个模板函数内部调用的时候，也会包含模板参数的类型名，这就达到了我们获取类型名字的目的。\n注意，类似于标准中提供的 __func__，__PRETTY_FUNCTION__ 是一个变量，因此它没法被用来初始化字符数组或者跟字符串字面量拼接在一起。MSVC 没有 __PRETTY_FUNCTION__，但是有一个类似功能的宏 __FUNCSIG__，它被替换为一个字符串字面量。\ntemplate\u003ctypename T\u003e constexpr std::string_view pretty_function() { return __PRETTY_FUNCTION__; } 在 Clang 上，调用 pretty_function() 会返回 std::string_view pretty_function() [T = int]，可以看到 T 的类型正在其中。\n请注意，这里的 typename T 不能直接省略成 typename，否则将不会出现 T 的类型名。\n当我们确定了函数名之后，返回的字符串的格式就确定了。我们可以去掉无用的前后缀，从而提取出我们实际需要的类型名。\nconstexpr const char PREFIX[] = \"std::string_view pretty_function() [T = \"; constexpr const char SUFFIX[] = \"]\"; template\u003ctypename T\u003e constexpr std::string_view type_name() { auto name = pretty_function\u003cT\u003e(); name.remove_prefix(sizeof(PREFIX) - 1); name.remove_suffix(sizeof(SUFFIX) - 1); return name; } 这样我们就实现了 std::type_info::name 的功能。再实现一个 constexpr 的 hash 函数，我们就实现了 std::type_index::hash_code 的功能。\nconstexpr size_t FNV_BASIS = 14695981039346656037ull; constexpr size_t FNV_PRIME = 1099511628211ull; constexpr size_t fnv1a_hash(std::string_view str) { size_t hash = FNV_BASIS; for (char c: str) hash = (hash ^ c) * FNV_PRIME; return hash; } template\u003ctypename T\u003e constexpr size_t type_hash() { auto name = type_name\u003cT\u003e(); return fnv1a_hash(name); } 关键的部分基本都解决了。有了这些，我们就可以组装出 std::type_info、std::type_index 等类了。\n可移植性 上面的代码中，__PRETTY_FUNCTION__ 是编译器相关的，其内容也是编译器相关的，需要针对不同编译器分别指定预定义变量/宏、PREFIX、SUFFIX。如果更改了相关函数的签名或者所在的命名空间，也需要相应地更改 PREFIX 和 SUFFIX。其余的部分都是可移植的。\n这里用到了 C++17 的std::string_view，它是可以 constexpr 构造的。而在 C++17 之前则可以直接返回 const char* 或者自己实现一个可 constexpr 构造的 std::string_view 类似物。\n安全性 __PRETTY_FUNCTION__ 中的类型名是带有完整命名空间路径以及模板参数（如果有的话）的，在不违背 C++ 的「单一定义规则」（One Definition Rule, ODR）的情况下，这一名字保证在每个翻译单元内唯一。若违背了 ODR，则程序非良构。\n实际测试下，即使对于 C++20 的类类型模板参数（Class Types in Non-Type Template Parameters），GCC、Clang、MSVC 三家也均能输出其中具体的内容，从而保证名字唯一。而其他的编译器在写下这篇文章的时候都还没有支持这个特性。\n更多 有一个名为 CTTI 的库是基于同样的原理写成的，本文在写作的过程中参考了它的代码。\n","wordCount":"210","inLanguage":"zh","datePublished":"2021-02-14T00:00:00Z","dateModified":"2021-02-14T00:00:00Z","author":{"@type":"Person","name":"QuarticCat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.quarticcat.com/zh/posts/cpp-ctti/"},"publisher":{"@type":"Organization","name":"QuarticCat's Blog","logo":{"@type":"ImageObject","url":"https://blog.quarticcat.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.quarticcat.com/zh/ accesskey=h title="Home (Alt + H)"><img src=https://blog.quarticcat.com/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.quarticcat.com/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://blog.quarticcat.com/zh/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.quarticcat.com/zh/tags/ title=标签><span>标签</span></a></li><li><a href=https://blog.quarticcat.com/zh/search/ title=搜索><span>搜索</span></a></li><li><a href=https://blog.quarticcat.com/zh/blogroll/ title=友链><span>友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">C++：编译期类型信息</h1><div class=post-meta><span title='2021-02-14 00:00:00 +0000 UTC'>2021-02-14</span>&nbsp;·&nbsp;QuarticCat</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#引言>引言</a></li><li><a href=#实现原理>实现原理</a></li><li><a href=#可移植性>可移植性</a></li><li><a href=#安全性>安全性</a></li><li><a href=#更多>更多</a></li></ul></nav></div></details></div><div class=post-content><h2 id=引言>引言<a hidden class=anchor aria-hidden=true href=#引言>#</a></h2><p>尽管标准库中已经有了 <a href=https://zh.cppreference.com/w/cpp/language/typeid><code>typeid</code></a> 运算符，但是由于其需要支持检查多态类型，带来了非常多的限制：</p><ol><li>它必须启用 RTTI（Run-Time Type Information）。而很多项目是禁用 RTTI 的，所以无法使用 <code>typeid</code>。</li><li>它可能对表达式进行求值，详见 <a href=https://zh.cppreference.com/w/cpp/language/typeid>cppreference</a> 。这可能带来意外的运行时开销甚至副作用，尤其是常用的 <code>sizeof</code> 和 <code>decltype</code> 都是完全静态的，不熟悉 <code>typeid</code> 的程序员可能完全意识不到这种动态行为的产生。</li><li>它不是 <code>constexpr</code> 的，即使其类型本可以静态求出。这意味着很多场景都无法使用 <code>typeid</code>，比如模板参数、switch-case 语句的 case 值等。</li></ol><p>这就是我们为什么需要编译期类型信息，即 CTTI（Compile-Time Type Information）。</p><h2 id=实现原理>实现原理<a hidden class=anchor aria-hidden=true href=#实现原理>#</a></h2><p>C++ 标准中并没有提供相关的设施供我们实现这一功能。但通过 GCC 和 Clang 的一个<strong>特殊的预定义变量</strong> <code>__PRETTY_FUNCTION__</code>，CTTI 得以实现。这个变量的值是当前函数完整签名的字符串。当在一个模板函数内部调用的时候，也会包含模板参数的类型名，这就达到了我们获取类型名字的目的。</p><p>注意，类似于标准中提供的 <a href=https://zh.cppreference.com/w/cpp/language/function#func><code>__func__</code></a>，<code>__PRETTY_FUNCTION__</code> 是一个变量，因此它没法被用来初始化字符数组或者跟字符串字面量拼接在一起。MSVC 没有 <code>__PRETTY_FUNCTION__</code>，但是有一个类似功能的宏 <code>__FUNCSIG__</code>，它被替换为一个字符串字面量。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> std<span style=color:#f92672>::</span>string_view pretty_function() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> __PRETTY_FUNCTION__;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在 Clang 上，调用 <code>pretty_function&lt;int>()</code> 会返回 <code>std::string_view pretty_function() [T = int]</code>，可以看到 <code>T</code> 的类型正在其中。</p><p>请注意，这里的 <code>typename T</code> 不能直接省略成 <code>typename</code>，否则将不会出现 <code>T</code> 的类型名。</p><p>当我们确定了函数名之后，返回的字符串的格式就确定了。我们可以去掉无用的前后缀，从而提取出我们实际需要的类型名。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> PREFIX[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;std::string_view pretty_function() [T = &#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> SUFFIX[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;]&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> std<span style=color:#f92672>::</span>string_view type_name() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> name <span style=color:#f92672>=</span> pretty_function<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>    name.remove_prefix(<span style=color:#66d9ef>sizeof</span>(PREFIX) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    name.remove_suffix(<span style=color:#66d9ef>sizeof</span>(SUFFIX) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> name;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样我们就实现了 <a href=https://zh.cppreference.com/w/cpp/types/type_info/name><code>std::type_info::name</code></a> 的功能。再实现一个 constexpr 的 hash 函数，我们就实现了 <a href=https://zh.cppreference.com/w/cpp/types/type_index/hash_code><code>std::type_index::hash_code</code></a> 的功能。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> size_t FNV_BASIS <span style=color:#f92672>=</span> <span style=color:#ae81ff>14695981039346656037ull</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> size_t FNV_PRIME <span style=color:#f92672>=</span> <span style=color:#ae81ff>1099511628211ull</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> size_t <span style=color:#a6e22e>fnv1a_hash</span>(std<span style=color:#f92672>::</span>string_view str) {
</span></span><span style=display:flex><span>    size_t hash <span style=color:#f92672>=</span> FNV_BASIS;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>char</span> c: str) hash <span style=color:#f92672>=</span> (hash <span style=color:#f92672>^</span> c) <span style=color:#f92672>*</span> FNV_PRIME;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> hash;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> size_t type_hash() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> name <span style=color:#f92672>=</span> type_name<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fnv1a_hash</span>(name);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>关键的部分基本都解决了。有了这些，我们就可以组装出 <code>std::type_info</code>、<code>std::type_index</code> 等类了。</p><h2 id=可移植性>可移植性<a hidden class=anchor aria-hidden=true href=#可移植性>#</a></h2><p>上面的代码中，<code>__PRETTY_FUNCTION__</code> 是编译器相关的，其内容也是编译器相关的，需要针对不同编译器分别指定预定义变量/宏、<code>PREFIX</code>、<code>SUFFIX</code>。如果更改了相关函数的签名或者所在的命名空间，也需要相应地更改 <code>PREFIX</code> 和 <code>SUFFIX</code>。其余的部分都是可移植的。</p><p>这里用到了 C++17 的<code>std::string_view</code>，它是可以 constexpr 构造的。而在 C++17 之前则可以直接返回 <code>const char*</code> 或者自己实现一个可 constexpr 构造的 <code>std::string_view</code> 类似物。</p><h2 id=安全性>安全性<a hidden class=anchor aria-hidden=true href=#安全性>#</a></h2><p><code>__PRETTY_FUNCTION__</code> 中的类型名是带有完整命名空间路径以及模板参数（如果有的话）的，在不违背 C++ 的<a href=https://zh.cppreference.com/w/cpp/language/definition>「单一定义规则」</a>（One Definition Rule, ODR）的情况下，这一名字保证在每个翻译单元内唯一。若违背了 ODR，则程序非良构。</p><p>实际测试下，即使对于 C++20 的类类型模板参数（Class Types in Non-Type Template Parameters），GCC、Clang、MSVC 三家也均能输出其中具体的内容，从而保证名字唯一。而其他的编译器在写下这篇文章的时候都还没有支持这个特性。</p><h2 id=更多>更多<a hidden class=anchor aria-hidden=true href=#更多>#</a></h2><p>有一个名为 <a href=https://github.com/Manu343726/ctti>CTTI</a> 的库是基于同样的原理写成的，本文在写作的过程中参考了它的代码。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.quarticcat.com/zh/tags/cpp/>Cpp</a></li></ul><nav class=paginav><a class=prev href=https://blog.quarticcat.com/zh/posts/cpp-encode-string-to-types/><span class=title>« 上一页</span><br><span>C++：把字符串编码进类型里</span>
</a><a class=next href=https://blog.quarticcat.com/zh/posts/read-cpp-types/><span class=title>下一页 »</span><br><span>C++ 类型阅读入门</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.quarticcat.com/zh/>QuarticCat's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>