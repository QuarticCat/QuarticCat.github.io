[{"content":"太久没更新博文了，水一篇凑数\n从 String View 说起 C 风格的字符串常常需要自己记录长度、管理生命周期，涉及长度变化时更是比较麻烦。于是在 C++ 中我们有了 std::string，并且有了与之配套的一系列函数，比如 std::stoi，对应 C 里面的 atoi。这个函数的声明如下：\nint stoi(const std::string\u0026amp; str, std::size_t* pos = 0, int base = 10); 这个接口接受一个 const std::string\u0026amp;，乍看或许是理所应当的：我是 C++ 函数，我需要读取字符串，但是我不需要修改它。实际上，C++ 中有很多接受 const std::string\u0026amp; 的函数，然而很遗憾，这个设计是失败的。\n考虑这样一种情况，我们需要读取一个 std::string 里的子串，但我们不需要修改它。比如对一个拥有很多数字的字符串进行连续 parse ，或者在某个大文本里找到某个模板再对匹配结果进行进一步筛选。这种情况下，这些接受 const std::string\u0026amp; 的函数就变得不好用了，因为子串不是一个 std::string 对象。我们往往不得不把子串复制到一个新的 std::string 对象里，造成了额外的开销。\n类似的常见情况还有，我们接收到了一个 C 风格的字符串，以 char* str + size_t len 的形式，而我们希望能在这个字符串上使用各种 C++ 函数的功能。比如跟 C 接口交互的时候，或者用 buffer 从别的地方接收字符串数据的时候。\n所以要怎么解决呢？我们可以采用 C 风格的接口，即 char* str + size_t len，或者采用迭代器风格的接口，即 char* begin + char* end。而将这两个参数合起来，我们就得到了 std::string_view ——只读字符串接口的正确答案。它不仅比 const std::string\u0026amp; 更泛用，而且在没有发生 SSO 的情况下，它还比 const std::string\u0026amp; 减少了一次指针跳转。\nRust 很早就想明白了这个问题，一开始就提供了 String（对应 C++ 的 string）和 \u0026amp;str（对应 C++ 的 string_view），并且在各个接口上统一了用法。而 C++ 则是群魔乱舞，什么样的接口都有。\n泛型的困境 假设你现在在写一个泛型容器 map\u0026lt;K, V\u0026gt;，你要给他添加一个 .find 成员来进行查找。那么 .find 的参数应该是什么呢？一般来说 const K\u0026amp; 就可以了，但要是 K = std::string，那么就会遇到前面所说的问题了。给 std::string 做一个特化吗？不，我们要考虑更一般的问题，即如何在泛型里处理一个类型有多种表示的情况。我们应该允许 .find 的参数是其他一些和 K 有关系的类型。C++ 的异质查找（heterogeneous lookup）说的就是这么样一种操作，异质在这里指的是存储的类型和查询的类型不一样。\n要解决这个问题也并不是很困难。在 std::map 等容器中原本就有一个 Compare 泛型参数用于设置比较器，我们只要接收一个可以比较不同类型的比较器并且把 .find 的参数放宽到任意类型就可以了。\n默认情况下，Compare 的值是 std::less\u0026lt;Key\u0026gt;，其 operator() 函数只能用于 Key 和 Key 的比较。在 C++14 后，std::less 等函数新增加了 void 特化，其 operator() 函数是一个模板，接受任意类型并返回 std::forward\u0026lt;T\u0026gt;(lhs) \u0026lt; std::forward\u0026lt;U\u0026gt;(rhs) 。我们只要将 std::map 的 Compare 参数设置成 std::less\u0026lt;\u0026gt; 即可使用异质查找。\nusing namespace std::literals::string_view_literals; std::map\u0026lt;std::string, int, std::less\u0026lt;\u0026gt;\u0026gt; foo; foo.find(\u0026#34;key\u0026#34;sv); 或者你也可以定制自己的比较器，只要它有个合法的成员类型 is_transparent，也会启用异质查找。\n以上是对 std::map 和 std::set 而言的。对于 unordered 系列容器，则是要求 Hash::is_transparent 和 KeyEqual::is_transparent。另外 unordered 系列容器的异质查找在 C++20 才被加入。\nRust 里的解决方案则是用一个 Borrow trait 来描述这种关系，相对来说约束更大一些。有兴趣的可以自行阅读文档，这里就不展开讲了。\n很遗憾 C++ 太晚意识到这些问题了，导致留下了大量的失败设计。为了兼容性考虑，异质查找不能默认启用，这导致启用了异质查找的和不启用的两个 std::map 类型是不一样的。所以即使这项功能已经可用，你也可能受限于旧有接口。\n","permalink":"https://blog.quarticcat.com/zh/posts/cpp-heterogeneous-lookup/","summary":"太久没更新博文了，水一篇凑数\n从 String View 说起 C 风格的字符串常常需要自己记录长度、管理生命周期，涉及长度变化时更是比较麻烦。于是在 C++ 中我们有了 std::string，并且有了与之配套的一系列函数，比如 std::stoi，对应 C 里面的 atoi。这个函数的声明如下：\nint stoi(const std::string\u0026amp; str, std::size_t* pos = 0, int base = 10); 这个接口接受一个 const std::string\u0026amp;，乍看或许是理所应当的：我是 C++ 函数，我需要读取字符串，但是我不需要修改它。实际上，C++ 中有很多接受 const std::string\u0026amp; 的函数，然而很遗憾，这个设计是失败的。\n考虑这样一种情况，我们需要读取一个 std::string 里的子串，但我们不需要修改它。比如对一个拥有很多数字的字符串进行连续 parse ，或者在某个大文本里找到某个模板再对匹配结果进行进一步筛选。这种情况下，这些接受 const std::string\u0026amp; 的函数就变得不好用了，因为子串不是一个 std::string 对象。我们往往不得不把子串复制到一个新的 std::string 对象里，造成了额外的开销。\n类似的常见情况还有，我们接收到了一个 C 风格的字符串，以 char* str + size_t len 的形式，而我们希望能在这个字符串上使用各种 C++ 函数的功能。比如跟 C 接口交互的时候，或者用 buffer 从别的地方接收字符串数据的时候。\n所以要怎么解决呢？我们可以采用 C 风格的接口，即 char* str + size_t len，或者采用迭代器风格的接口，即 char* begin + char* end。而将这两个参数合起来，我们就得到了 std::string_view ——只读字符串接口的正确答案。它不仅比 const std::string\u0026amp; 更泛用，而且在没有发生 SSO 的情况下，它还比 const std::string\u0026amp; 减少了一次指针跳转。","title":"C++：异质查找（heterogeneous lookup）"},{"content":"众所周知，C++ 的名称查找一直以来都很反直觉。比如臭名昭著的 ADL，这玩意经常在意想不到的地方恶心到你，还往往难以排查。具体表现为你在当前的命名空间里自己定义了一个函数，结果在调用它的时候编译器却找到了十万八千里外的另一个同名函数，即使你没有在当前命名空间引入该函数。下面是两个很常见的例子：\nnamespace fuckadl { struct Fuck {}; void foo(Fuck) { puts(\u0026#34;not mine\u0026#34;); } } // namespace fuckadl // case 1 void foo(fuckadl::Fuck) { puts(\u0026#34;mine\u0026#34;); } // // case 2 // template\u0026lt;class T\u0026gt; // void foo(T) { puts(\u0026#34;mine\u0026#34;); } int main() { foo(fuckadl::Fuck{}); } 对于 case 1 ，你会得到一个编译错误。编译器告诉你不知道该选择哪个 foo 函数。而对于 case 2，你甚至一个警告都不会得到，编译器自动就选择了 fuckadl::foo 。假如是不知道这个 feature 的 C++ 新人，怕是 debug 一天也找不到哪里出了问题。\n这种设计直接破坏了命名空间的封装意义，要知道无数的 header only 库都在用命名空间来对外隐藏内部符号（谁让 C++ 的模块机制拖延了这么久呢），你都没法知道什么时候就和别人函数名字撞上了。\n最近发现了 C++ 名称查找的又一个恶心设计。来请出我们的主角，C++ Standard Draft N3337 10.2 Member name lookup [class.member.lookup]:\nMember name lookup determines the meaning of a name (id-expression) in a class scope (3.3.7). Name lookup can result in an ambiguity, in which case the program is ill-formed. For an id-expression, name lookup begins in the class scope of this; for a qualified-id, name lookup begins in the scope of the nested-name-specifier. Name lookup takes place before access control (3.4, Clause 11). 最后一句是重点，它意味着在进行 name lookup 的时候看不到 public、private 之类的 access specifier 。下面我给出一个非常违反直觉的 case（修改自该问题）：\nstruct Base { operator bool() { return true; } }; struct Derived: private Base { operator int() { return 1; } }; int main() { std::cout \u0026lt;\u0026lt; Derived{}; } 请注意这里使用了 private 继承。不严谨地解释的话，Derived 类对于调用者来说实际相当于这样：\nstruct Derived { public: operator int() { return 1; } private: operator bool() { return true; } }; 然而这串代码编译器会报二义性错误，没错！因为编译器这时还看不到 access specifier，因此 operator bool() 和 operator int() 都会当作候选，于是就产生二义性了。\n由于 C++ 没有 Zero-Sized Types ，在 C++20 出现 [[no_unique_address]] 之前，我们想要引入零大小成员的一种方式就是使用 private / protected 继承，利用空基类优化来实现 zero size。这在模板库中并不是一种极度罕见的技巧，Boost 的 compressed_pair 就是以这种方式实现的。\n然而由于 C++ 名称查找的这一恶心特性，我们在使用这种技巧时将不得不考虑基类的所有成员是什么，是否会与派生类产生意外的结果，哪怕我们使用的是 private 继承。这实在是太离谱了，绝对可以算得上是一种抽象泄露。\n好吧，如果你说你不会用到 private 继承，那么下面我给出一个更容易见到的例子：\nstruct Base1 { public: int x = 1; }; struct Base2 { private: int x = 1; }; struct Derived: Base1, Base2 {}; int main() { Derived{}.x; } 这串代码编译器也会报二义性错误，同样的，因为编译器在查找 .x 的时候还看不到 access specifier ，它发现 Base1 和 Base2 都有一个 x 成员，就产生了二义性。\n这个例子更离谱一些。想象一下，假如其中 Base2 来自外部，那么你在它的接口文档中根本不会看到它内部有这么一个成员，而极大概率这个成员的名字也是不保证的，毕竟属于它的内部实现。然而这个成员却会妨碍你的名称查找！跟 ADL 的问题一样，这封装已经漏成筛子了，封装了个寂寞。\n当然和 ADL 的问题一样，并不是没有办法绕过，只需要稍微改下 Derived 类即可，只是这种问题的存在实在让人恶心。\nstruct Derived: Base1, Base2 { using Base1::x; }; 接下来是最离谱的事情：二义性错误也可以触发 substitution failure ，因此可以被用于 SFINAE 或者 Concept 。那么结合上文，我们可以在外部探测到一个类是否拥有某个 private / protected 成员。\n假如我们要探测一个类是否有名为 x 的成员，不论 public 与否，那么我们可以构造一个具有成员 x 的类 A ，再构造一个类 B 同时继承 A 和待检测的类，然后通过访问 B 的 x 成员来制造 substitution failure 。代码如下：\nstruct A { int x; }; template\u0026lt;class T\u0026gt; struct B: A, T {}; template\u0026lt;class T\u0026gt; concept TestX = !requires(B\u0026lt;T\u0026gt; b) { b.x; }; 最后我们写两个简单的测试样例：\nstruct HasX { private: int x; }; struct HasY { private: int y; }; static_assert(TestX\u0026lt;HasX\u0026gt;); static_assert(TestX\u0026lt;HasY\u0026gt;); 可以看到只有 TestX\u0026lt;HasY\u0026gt; 为 false 。\n","permalink":"https://blog.quarticcat.com/zh/posts/one-more-nasty-design-of-cpp-name-lookup/","summary":"众所周知，C++ 的名称查找一直以来都很反直觉。比如臭名昭著的 ADL，这玩意经常在意想不到的地方恶心到你，还往往难以排查。具体表现为你在当前的命名空间里自己定义了一个函数，结果在调用它的时候编译器却找到了十万八千里外的另一个同名函数，即使你没有在当前命名空间引入该函数。下面是两个很常见的例子：\nnamespace fuckadl { struct Fuck {}; void foo(Fuck) { puts(\u0026#34;not mine\u0026#34;); } } // namespace fuckadl // case 1 void foo(fuckadl::Fuck) { puts(\u0026#34;mine\u0026#34;); } // // case 2 // template\u0026lt;class T\u0026gt; // void foo(T) { puts(\u0026#34;mine\u0026#34;); } int main() { foo(fuckadl::Fuck{}); } 对于 case 1 ，你会得到一个编译错误。编译器告诉你不知道该选择哪个 foo 函数。而对于 case 2，你甚至一个警告都不会得到，编译器自动就选择了 fuckadl::foo 。假如是不知道这个 feature 的 C++ 新人，怕是 debug 一天也找不到哪里出了问题。\n这种设计直接破坏了命名空间的封装意义，要知道无数的 header only 库都在用命名空间来对外隐藏内部符号（谁让 C++ 的模块机制拖延了这么久呢），你都没法知道什么时候就和别人函数名字撞上了。\n最近发现了 C++ 名称查找的又一个恶心设计。来请出我们的主角，C++ Standard Draft N3337 10.","title":"C++ 名称查找的又一个恶心设计"},{"content":"又到了我第 114514 喜欢的类型体操环节。\n这玩意有什么用 非要举一个具有实用意义的场景的话，PEGTL 是我能想到的一个很好的例子。这是一个 parser combinator 库，它使用类型来组合 parser ，比如这样：\nstruct separator: star\u0026lt;one\u0026lt;\u0026#39; \u0026#39;, \u0026#39;\\t\u0026#39;, \u0026#39;\\r\u0026#39;, \u0026#39;\\n\u0026#39;\u0026gt;\u0026gt; {}; 那么要 parse 一段字符串的时候当然就要把字符串信息编码进类型里面了。\n我在自己的玩具 parser combinator 库里也用了这种方法，只不过我写法上使用变量来组合。\n除此之外，著名的 fmt 库也用到了这个东西来进行大量的编译期字符串操作。但它为了兼容性，实现方式都比较原始，而且重复实现了大量标准库中后来加入或者被标记为 constexpr 的东西，也许我有时间会用 C++20 实现一个简易版的 fmt 库。\n不就是个 char... 吗 看了上面的例子，肯定有人会这么想。但其实再想想，我们可以有好几种方案在模板参数里接收一个字符串：\ntemplate\u0026lt;const char* /* , size_t N */\u0026gt; struct Str1 {}; template\u0026lt;char...\u0026gt; struct Str2 {}; // Need C++20, will explain later template\u0026lt;SomeUserDefinedString\u0026gt; struct Str3 {}; 为什么这里不写数组类型呢，因为在模板参数里，数组类型会被自动替换成指针，和第一种方案实际上是一样的。总之就这么三个，我们一个一个来讲。\n方案一 template\u0026lt;const char* /* , size_t N */\u0026gt; struct Str1 {}; 把它放在第一个讲是因为它是最废物的，只要一写就发现：\nconstexpr Str1\u0026lt;\u0026#34;123\u0026#34;\u0026gt; s1; 诶，编译器怎么拒绝了？GCC 在这里会直接告诉你 string literals can never be used in this context，而 Clang 则在打谜语。其实并非这个模板参数用不了，而是你得这么写才合法：\nconstexpr const char chars[] = \u0026#34;123\u0026#34;; constexpr Str1\u0026lt;chars\u0026gt; s2; 这可太拉垮了，每个类型都得在某个地方先定义一个字符串才能用。而且这是两条语句而不是表达式，很多场景下没法用宏组合到一起。我想写出一套流畅的类型嵌套，或者至少，constexpr 变量表达式，怎么办？有经验的人可能会想到立即调用 lambda ：\nconstexpr auto s3 = [] { constexpr const char chars[] = \u0026#34;123\u0026#34;; return Str1\u0026lt;chars\u0026gt;{}; }(); 然后咱再用宏把这 lambda 调用包一层，不就是个好用的表达式了吗？想得美，编译器立马把 error 拍你脸上。Clang 还在打谜语，就不提了，GCC 直接告诉你问题是这里模板参数需要静态存储期。于是你可能又想，咱加个static不就完事了：\nconstexpr auto s4 = [] { static constexpr const char chars[] = \u0026#34;123\u0026#34;; return Str1\u0026lt;chars\u0026gt;{}; }(); 结果这个 lambda 就变成非 constexpr 的了，哈哈哈哈哈。总之，这条路大约的确是走不通了。\n方案二 template\u0026lt;char...\u0026gt; struct Str2 {}; 这是最常见的，也是还比较好用的。想要有字符串的体验只需要在结构体内部写个 constexpr const char chars[] = {Cs..., '\\0'} 就完事了。定义也很直观，直接写 Str2\u0026lt;'1', '2', '3'\u0026gt;。唯一的问题就是，无关的字符太多了，字符串一长写起来就很难受。所以接下来就得想想怎么简化这个类型的书写。\n用户定义字面量 一种可行的简化方法是用用户定义字面量。但很可惜，标准的字面量太弱了，没法取到字符串字面量的 char...，只能取到数值字面量的。所以最多只能写出这种代码：\ntemplate\u0026lt;char... Cs\u0026gt; constexpr Str2\u0026lt;Cs...\u0026gt; operator\u0026#34;\u0026#34;_s() { return {}; } constexpr auto s5 = 123_s; // OK constexpr auto s6 = \u0026#34;abc\u0026#34;_s; // Error 而只有依赖 GCC 与 Clang 的扩展，我们才能成功定义出期望的字面量：\ntemplate\u0026lt;class CharT, CharT... Cs\u0026gt; constexpr Str2\u0026lt;Cs...\u0026gt; operator\u0026#34;\u0026#34;_s() { return {}; } constexpr auto s7 = \u0026#34;123\u0026#34;_s; 当你期望取得一个类型而不是 constexpr 变量时，也只需要一个 decltype 就足够了：\nusing T = decltype(\u0026#34;123\u0026#34;_s); 如果嫌长可以用宏包一层。\n模板展开 这个方法的灵感来自于 stackoverflow 上的一个回答。原代码很长不过大部分都是废话，只不过是利用 C++11 后模板允许传局部 struct 这一点来传递临时字符串，在元函数里生成下标序列然后产生取下标表达式的展开，从而把临时字符串转化成字符参数序列。最后用个 lambda 包起来，就是个表达式了。\n理解了原理以后很容易写出一个简化的版本。有了 C++14 的 std::index_sequence，这种简单的递归完全不需要自己写：\ntemplate\u0026lt;class S, size_t... Is\u0026gt; constexpr auto helper(std::index_sequence\u0026lt;Is...\u0026gt;) { return Str2\u0026lt;S{}.s[Is]...\u0026gt;{}; } #define STR(str) \\ [] { \\ struct S { const char* s = str; }; \\ return helper\u0026lt;S\u0026gt;(std::make_index_sequence\u0026lt;sizeof(str) - 1\u0026gt;{}); \\ }() constexpr auto s8 = STR(\u0026#34;123\u0026#34;); 注意这里还用到了 constexpr lambda ，这是一个 C++17 的特性。这个方法有个缺陷是在 C++20 前没法直接取得类型，因为这之前 lambda 不能用在不求值语境里，没法包个 decltype。\n而当我们来到了 C++20 ，有了 template lambda ，我们甚至可以只用四行写出这个宏：\n#define STR(str) \\ []\u0026lt;size_t... Is\u0026gt;(std::index_sequence\u0026lt;Is...\u0026gt;) { \\ return Str2\u0026lt;str[Is]...\u0026gt;{}; \\ }(std::make_index_sequence\u0026lt;sizeof(str) - 1\u0026gt;{}) constexpr auto s8 = STR(\u0026#34;123\u0026#34;); 只不过有个问题，既然都上了 C++20 ，那还不如直接看方案三。\n宏展开 其实思路和模板展开是完全一致的，好处是可以直接获得类型，坏处就是写起来很长，以及允许的字符串长度有限制（但可以轻松扩展），而且字符串类型内部需要处理一下末尾的 0。\n#define STR_EXPAND_1(str, i) \\ (sizeof(str) \u0026gt; (i) ? str[i] : 0) #define STR_EXPAND_4(str, i) \\ STR_EXPAND_1(str, i+0), \\ STR_EXPAND_1(str, i+1), \\ STR_EXPAND_1(str, i+2), \\ STR_EXPAND_1(str, i+3) #define STR_EXPAND_16(str, i) \\ STR_EXPAND_4(str, i+0), \\ STR_EXPAND_4(str, i+4), \\ STR_EXPAND_4(str, i+8), \\ STR_EXPAND_4(str, i+12) #define STR_EXPAND_64(str, i) \\ STR_EXPAND_16(str, i+0), \\ STR_EXPAND_16(str, i+16), \\ STR_EXPAND_16(str, i+32), \\ STR_EXPAND_16(str, i+48) #define STR(str) Str2\u0026lt;STR_EXPAND_64(str, 0)\u0026gt; using T = STR(\u0026#34;123\u0026#34;); constexpr auto s9 = STR(\u0026#34;123\u0026#34;){}; 这个也是 PEGTL 内部使用的方法，因为 PEGTL 是用类型来组合的。\n方案三 template\u0026lt;SomeUserDefinedString\u0026gt; struct Str3 {}; 有了 C++20 对 NTTP 的扩展，我们终于可以写出来一个不需要任何宏和编译器扩展就方便好用的字符串模板参数了！原理也很简单，就是自己写一个符合 NTTP 要求的类，把字符串复制一份，这样模板参数就拥有字符串的所有权了，方案一遇到的那些问题也就不复存在。\ntemplate\u0026lt;size_t N\u0026gt; struct StrTP { char str[N]; constexpr StrTP(const char (\u0026amp;s)[N]) { for (size_t i = 0; i \u0026lt; N; ++i) str[i] = s[i]; } }; template\u0026lt;StrTP S\u0026gt; class Str3 {}; constexpr Str3\u0026lt;\u0026#34;123\u0026#34;\u0026gt; s10; 再包一层模板变量也是可以的：\ntemplate\u0026lt;StrTP S\u0026gt; constexpr Str3\u0026lt;S\u0026gt; str3{}; constexpr auto s11 = str3\u0026lt;\u0026#34;123\u0026#34;\u0026gt;; 或者再包一层用户定义字面量也毫无问题：\ntemplate\u0026lt;StrTP S\u0026gt; constexpr Str3\u0026lt;S\u0026gt; operator\u0026#34;\u0026#34;_s() { return {}; } constexpr auto s12 = \u0026#34;123\u0026#34;_s; 我愿称之为最完美方案。\n","permalink":"https://blog.quarticcat.com/zh/posts/cpp-encode-string-to-types/","summary":"又到了我第 114514 喜欢的类型体操环节。\n这玩意有什么用 非要举一个具有实用意义的场景的话，PEGTL 是我能想到的一个很好的例子。这是一个 parser combinator 库，它使用类型来组合 parser ，比如这样：\nstruct separator: star\u0026lt;one\u0026lt;\u0026#39; \u0026#39;, \u0026#39;\\t\u0026#39;, \u0026#39;\\r\u0026#39;, \u0026#39;\\n\u0026#39;\u0026gt;\u0026gt; {}; 那么要 parse 一段字符串的时候当然就要把字符串信息编码进类型里面了。\n我在自己的玩具 parser combinator 库里也用了这种方法，只不过我写法上使用变量来组合。\n除此之外，著名的 fmt 库也用到了这个东西来进行大量的编译期字符串操作。但它为了兼容性，实现方式都比较原始，而且重复实现了大量标准库中后来加入或者被标记为 constexpr 的东西，也许我有时间会用 C++20 实现一个简易版的 fmt 库。\n不就是个 char... 吗 看了上面的例子，肯定有人会这么想。但其实再想想，我们可以有好几种方案在模板参数里接收一个字符串：\ntemplate\u0026lt;const char* /* , size_t N */\u0026gt; struct Str1 {}; template\u0026lt;char...\u0026gt; struct Str2 {}; // Need C++20, will explain later template\u0026lt;SomeUserDefinedString\u0026gt; struct Str3 {}; 为什么这里不写数组类型呢，因为在模板参数里，数组类型会被自动替换成指针，和第一种方案实际上是一样的。总之就这么三个，我们一个一个来讲。\n方案一 template\u0026lt;const char* /* , size_t N */\u0026gt; struct Str1 {}; 把它放在第一个讲是因为它是最废物的，只要一写就发现：","title":"C++：把字符串编码进类型里"},{"content":"引言 尽管标准库中已经有了 typeid 运算符，但是由于其需要支持检查多态类型，带来了非常多的限制：\n它必须启用 RTTI（Run-Time Type Information）。而很多项目是禁用 RTTI 的，所以无法使用 typeid。 它可能对表达式进行求值，详见 cppreference 。这可能带来意外的运行时开销甚至副作用，尤其是常用的 sizeof 和 decltype 都是完全静态的，不熟悉 typeid 的程序员可能完全意识不到这种动态行为的产生。 它不是 constexpr 的，即使其类型本可以静态求出。这意味着很多场景都无法使用 typeid，比如模板参数、switch-case 语句的 case 值等。 这就是我们为什么需要编译期类型信息，即 CTTI（Compile-Time Type Information）。\n实现原理 C++ 标准中并没有提供相关的设施供我们实现这一功能。但通过 GCC 和 Clang 的一个特殊的预定义变量 __PRETTY_FUNCTION__，CTTI 得以实现。这个变量的值是当前函数完整签名的字符串。当在一个模板函数内部调用的时候，也会包含模板参数的类型名，这就达到了我们获取类型名字的目的。\n注意，类似于标准中提供的 __func__，__PRETTY_FUNCTION__ 是一个变量，因此它没法被用来初始化字符数组或者跟字符串字面量拼接在一起。MSVC 没有 __PRETTY_FUNCTION__，但是有一个类似功能的宏 __FUNCSIG__，它被替换为一个字符串字面量。\ntemplate\u0026lt;typename T\u0026gt; constexpr std::string_view pretty_function() { return __PRETTY_FUNCTION__; } 在 Clang 上，调用 pretty_function\u0026lt;int\u0026gt;() 会返回 std::string_view pretty_function() [T = int]，可以看到 T 的类型正在其中。\n请注意，这里的 typename T 不能直接省略成 typename，否则将不会出现 T 的类型名。\n当我们确定了函数名之后，返回的字符串的格式就确定了。我们可以去掉无用的前后缀，从而提取出我们实际需要的类型名。\nconstexpr const char PREFIX[] = \u0026#34;std::string_view pretty_function() [T = \u0026#34;; constexpr const char SUFFIX[] = \u0026#34;]\u0026#34;; template\u0026lt;typename T\u0026gt; constexpr std::string_view type_name() { auto name = pretty_function\u0026lt;T\u0026gt;(); name.remove_prefix(sizeof(PREFIX) - 1); name.remove_suffix(sizeof(SUFFIX) - 1); return name; } 这样我们就实现了 std::type_info::name 的功能。再实现一个 constexpr 的 hash 函数，我们就实现了 std::type_index::hash_code 的功能。\nconstexpr size_t FNV_BASIS = 14695981039346656037ull; constexpr size_t FNV_PRIME = 1099511628211ull; constexpr size_t fnv1a_hash(std::string_view str) { size_t hash = FNV_BASIS; for (char c: str) hash = (hash ^ c) * FNV_PRIME; return hash; } template\u0026lt;typename T\u0026gt; constexpr size_t type_hash() { auto name = type_name\u0026lt;T\u0026gt;(); return fnv1a_hash(name); } 关键的部分基本都解决了。有了这些，我们就可以组装出 std::type_info、std::type_index 等类了。\n可移植性 上面的代码中，__PRETTY_FUNCTION__ 是编译器相关的，其内容也是编译器相关的，需要针对不同编译器分别指定预定义变量/宏、PREFIX、SUFFIX。如果更改了相关函数的签名或者所在的命名空间，也需要相应地更改 PREFIX 和 SUFFIX。其余的部分都是可移植的。\n这里用到了 C++17 的std::string_view，它是可以 constexpr 构造的。而在 C++17 之前则可以直接返回 const char* 或者自己实现一个可 constexpr 构造的 std::string_view 类似物。\n安全性 __PRETTY_FUNCTION__ 中的类型名是带有完整命名空间路径以及模板参数（如果有的话）的，在不违背 C++ 的「单一定义规则」（One Definition Rule, ODR）的情况下，这一名字保证在每个翻译单元内唯一。若违背了 ODR，则程序非良构。\n实际测试下，即使对于 C++20 的类类型模板参数（Class Types in Non-Type Template Parameters），GCC、Clang、MSVC 三家也均能输出其中具体的内容，从而保证名字唯一。而其他的编译器在写下这篇文章的时候都还没有支持这个特性。\n更多 有一个名为 CTTI 的库是基于同样的原理写成的，本文在写作的过程中参考了它的代码。\n","permalink":"https://blog.quarticcat.com/zh/posts/cpp-ctti/","summary":"引言 尽管标准库中已经有了 typeid 运算符，但是由于其需要支持检查多态类型，带来了非常多的限制：\n它必须启用 RTTI（Run-Time Type Information）。而很多项目是禁用 RTTI 的，所以无法使用 typeid。 它可能对表达式进行求值，详见 cppreference 。这可能带来意外的运行时开销甚至副作用，尤其是常用的 sizeof 和 decltype 都是完全静态的，不熟悉 typeid 的程序员可能完全意识不到这种动态行为的产生。 它不是 constexpr 的，即使其类型本可以静态求出。这意味着很多场景都无法使用 typeid，比如模板参数、switch-case 语句的 case 值等。 这就是我们为什么需要编译期类型信息，即 CTTI（Compile-Time Type Information）。\n实现原理 C++ 标准中并没有提供相关的设施供我们实现这一功能。但通过 GCC 和 Clang 的一个特殊的预定义变量 __PRETTY_FUNCTION__，CTTI 得以实现。这个变量的值是当前函数完整签名的字符串。当在一个模板函数内部调用的时候，也会包含模板参数的类型名，这就达到了我们获取类型名字的目的。\n注意，类似于标准中提供的 __func__，__PRETTY_FUNCTION__ 是一个变量，因此它没法被用来初始化字符数组或者跟字符串字面量拼接在一起。MSVC 没有 __PRETTY_FUNCTION__，但是有一个类似功能的宏 __FUNCSIG__，它被替换为一个字符串字面量。\ntemplate\u0026lt;typename T\u0026gt; constexpr std::string_view pretty_function() { return __PRETTY_FUNCTION__; } 在 Clang 上，调用 pretty_function\u0026lt;int\u0026gt;() 会返回 std::string_view pretty_function() [T = int]，可以看到 T 的类型正在其中。\n请注意，这里的 typename T 不能直接省略成 typename，否则将不会出现 T 的类型名。","title":"C++：编译期类型信息"},{"content":"C++ 的类型可读性很差，并且大多数入门材料中并没有详细介绍如何阅读它们，最多只是讲到 top-level const 和 low-level const 的区别。有不少朋友问过我这方面的问题，讲得多了，干脆整理起来写篇文章。\n常见误解 在详细讲类型的阅读之前，需要纠正一个常见的误解。\n问：int a[5] 里的 a 是什么类型的？\n答：int[5] 类型，在适当的时候会「退化」（decay）成为 int* 类型。\n问：int a[5][6] 里的 a 是什么类型的？\n答：int[5][6] 类型，在适当的时候会「退化」成为 int(*)[6] 类型，即指向 int[6] 的指针。\n由于「退化」这种隐式转换的存在，很多初学 C++ 的人会把数组类型等同于指针类型。\n类似的，函数类型也会「退化」到指针类型，如 int(int, int) 会「退化」成为 int(*)(int, int)。\n解方程 当你查阅如何阅读一些复杂的类型时，你可能会看到网络上一些人说 C++ 的类型就是解方程，让我来详细解释一下这句话。\n抛去 CVR (const, volatile, reference) 等不谈，C++ 最基本的声明分为两个部分：写在最左边的类型名是「类型说明符」（type specifier），剩下的部分是「声明符」（declarator）。这部分内容是从 C 继承过来的，它们是 C++ 类型里最恶心的地方。但这两个名字实在没啥识别度，我喜欢不严谨地称呼为返回值类型和调用表达式，这点后面会解释。先来看几个例子吧：\n声明 类型说明符 声明符 int a int a int* a int *a int a[5] int a[5] int* a[5] int *a[5] int (*a)[5] int (*a)[5] 作出这种分别后，就可以理解上表中a的类型是怎样决定的了：以「声明符」的形式调用a后，得到的返回值类型为「类型说明符」。所谓的解方程就是这样一个过程：\n由 int *a[5] 得到 *a[5] 的类型是 int。 即对 a[5] 解引用得到 int ，推出 a[5] 的类型是 int*。 即对 a 取下标得到 int* ，推出 a 的类型是 5 个 int* 的数组。 再比如：\n由 int (*a)[5] 得到 (*a)[5] 的类型是 int。 即对 (*a) 取下标得到 int，推出 (*a) 的类型是 int[5]。 即对 a 解引用得到 int[5]，推出 a 的类型是指向 int[5] 的指针。 可以看到这里运算符优先级和调用时完全一致，形式上也基本一致。\n再来个函数指针的例子：\n由 int (*a)(int, int) 得到 (*a)(int, int) 的类型是 int。 即对 (*a) 以 (int, int) 的形式调用得到 int，推出 (*a) 的类型是有两个 int 参数并且返回 int 的函数，即 int(int, int)。 即对 a 解引用得到 int(int, int)，推出 a 的类型是指向 int(int, int) 的指针。 更复杂一点：\n由 int (*(Foo::*a[5])(int, int))(int) 得到 (*(Foo::*a[5])(int, int))(int) 的类型是 int。 推出 (*(Foo::*a[5])(int, int)) 的类型是 int(int)。 推出 (Foo::*a[5])(int, int) 的类型是指向 int(int) 的指针，即 int(*)(int)。 推出 (Foo::*a[5]) 的类型是有两个 int 参数并且返回 int(*)(int) 的函数。 推出 a[5] 的类型是指向这种函数的成员指针。 推出 a 的类型是 5 个这种成员指针的数组。 简而言之，你可以把「声明符」部分看成一个调用表达式，这个调用表达式的返回值类型为「类型说明符」，这样就可以一步步倒推出类型来。\n当然了，这么复杂的类型是不推荐这么写的，这里只是为了演示一下解方程的过程。上面那个a正常一点的声明大概会长这样：\nstruct Foo { auto bar(int, int) -\u0026gt; int(*)(int); }; decltype(\u0026amp;Foo::bar) a[5]; 即使在 C++11 以前，也可以利用 typedef 拆解成多层，提升可读性：\nstruct Foo { typedef int (*bar_t)(int); bar_t bar(int, int); }; typedef Foo::bar_t (Foo::*foo_bar_t)(int, int); foo_bar_t a[5]; 这种包装在 C 语言中还是挺常见的。\n不过如果你要看的类型是 demangle 出来的（或者其他查看类型名的方式），那就是长成那种魔鬼样子了。\n多变量声明 有了前面的知识，就能够理解 C++ 多变量声明的规则了。多变量声明中，逗号分割的是「声明符」（即调用表达式部分），它们共享「类型说明符」（即返回值部分），比如：\nint *a, b; 其中 a 的类型为 int* 而 b 的类型则为 int，因为 * 是「声明符」的一部分。如果你希望定义两个指针，那么应该写成 int *a, *b。\n更复杂的例子也遵循同样的规则。因为实在想不到更复杂的情况这样写有什么意义，就不再举例子了。\nconst 与 volatile const 与 volatile 在类型中的位置是一样的，并且他们两个可以一起使用，因此这里仅仅用 const 作为例子。下面出现的所有 const 都可以合法地替换成 volatile、const volatile 和 volatile const，后两者语义上等价。\nconst 在一般情况下都很明确，如 const int a 和 int (*a)(const std::string\u0026amp;)。const 的理解障碍主要出在指针的情况中。对于指针来说，const 需要能表达两种含义：\n指针本身是 const 的，即这个指针没法再指向别的值，如 char *const a。 指针所指向的对象是 const 的，即你没法通过这个指针修改它指向的对象，如 const char* a。 当指针嵌套时，我们还要考虑指针指向的指针的 const 属性，于是类型就变得复杂起来。有了前面的知识，我们可以把 const 分为修饰「类型说明符」的 const 和修饰「声明符」的 const。看下面这个类型：\nconst int * const * * const a; 从左往右的第一个 const 为修饰「类型说明符」的 const，其余的为修饰「声明符」的 const。\n修饰「类型说明符」的 const 只要写在「类型说明符」旁边，不论 const T 还是 T const 都是合法且等价的。也就是上面这个例子还可以写成：\nint const * const * * const a; 它们都说明：\n* const * * const a（当然去掉 const 后它才是一个合法的表达式，下同）的类型为 const int（不能修改 ***a） 修饰「声明符」的 const 只要看解方程时解到哪个表达式，就说明修饰的是哪个表达式的类型。接着上面这个例子：\n推出 * * const a 是一个指向 const int 的 const 指针（不能修改 **a） 推出 * const a 是一个指向前面那个指针的非 const 指针（可以修改 *a） 推出 a 是一个指向前面那个指针的 const 指针（不能修改 a） 著名的 C++ 入门书籍《C++ Primer》把 const 分为了「顶层 const 」（top-level const）和「底层 const 」（low-level const）（此为原版翻译，显然并不准确）。顶层指的是修饰指针自身的，也就是类型中最内层的；底层指的是其余的。这两个术语在只讨论一层指针的时候才比较好用，当然这也是绝大多数情况。\n\u0026amp; 与 \u0026amp;\u0026amp; C++ 的引用是一种非常特殊的类型。由于 C++ 规定引用不一定占用内存，所以你既没法写出引用类型的数组（int\u0026amp; a[5]），也没法写出指向引用类型的指针（int\u0026amp;* a），除此之外还有很多地方无法使用引用。我认为这是一个非常失败的设计，凭空增加了很多障碍。它明明只是一个「不可空指针」（non-nullable pointer）而已。右值引用也并没有什么特别，只是带有所有权转移语义的引用而已。\n总之，除了函数类型（以及嵌套了函数类型的类型）里 \u0026amp; 和 \u0026amp;\u0026amp; 会出现在参数类型和返回值类型中，其他情况下 \u0026amp; 和 \u0026amp;\u0026amp; 只会出现在类型的最顶层。这里的顶层的含义与前文的「顶层 const 」相同。\n\u0026amp; 和 \u0026amp;\u0026amp; 没法直接嵌套使用，比如 int\u0026amp; \u0026amp;\u0026amp; a 是非法的。但是间接嵌套是合法的，比如：\nusing ref1 = int\u0026amp;\u0026amp;; using ref2 = ref1\u0026amp;\u0026amp;; using ref3 = ref2\u0026amp;; 在这种情况下会发生「引用折叠」（reference collapsing）。规则也很简单，如果全是 \u0026amp;\u0026amp;，那么会折叠成一个 \u0026amp;\u0026amp;。只要有一个 \u0026amp;，就会折叠成 \u0026amp;。比如上面的 ref2 实际上是 int\u0026amp;\u0026amp;，而 ref3 则是 int\u0026amp;。\n\u0026amp;\u0026amp; 还有一种用法是在模板中。如果 T 是一个模板参数，那么 T\u0026amp;\u0026amp;（不能带有 const 和 volatile）就是一个「万能引用」（universal reference）。具体规则为：\n如果传入 T\u0026amp;\u0026amp; 的类型为 Foo\u0026amp;，那么 T 就被推导为 Foo\u0026amp;，而 T\u0026amp;\u0026amp; 经过折叠变成 Foo\u0026amp;。 如果传入 T\u0026amp;\u0026amp; 的类型为 Foo\u0026amp;\u0026amp;，那么 T 就被推导为 Foo，而 T\u0026amp;\u0026amp; 则是 Foo\u0026amp;\u0026amp;。 请注意，T 被推导为什么类型这一点很重要，因为你可能在模板内部再次使用 T。\n成员函数 在 C++ 的成员函数中，我们有时会见到这样的例子：\nstruct Foo { int a(int, int) const; }; struct Bar { int a(int, int) \u0026amp;\u0026amp;; }; 这个其实也很好理解。C++ 的非 static 成员函数都可以调用 this，一个指向实例的指针。写在后面的 const 和 \u0026amp;\u0026amp; 就是用来修饰实例的。\n在其他一些语言（比如 Rust 和 Python ）中传入的实例是显式地作为第一个参数写出的，而 C++ 是隐式的（在 C++23 前），于是只能在其他地方加上类型修饰。不过即使不是隐式的，你也没法在 C++ 中直接写出 this 的类型，但这仍然是 C++ 的锅——因为 this 是一个指针，而 C++ 中指针没法指向引用类型。下面两个例子用注释不严谨地揭示了后置的类型修饰是怎么运作的：\nstruct Foo { // void a(const Foo\u0026amp; this_, int) { // const Foo* this = \u0026amp;this_; // } void a(int) const\u0026amp;; // void a(Foo\u0026amp;\u0026amp; this_, int) { // Foo* this = \u0026amp;this_; // } void a(int) \u0026amp;\u0026amp;; // void a(Foo\u0026amp; this_, int) { // Foo* this = \u0026amp;this_; // } void a(int) \u0026amp;; // foo.a(1) -\u0026gt; Foo::a(foo, 1) }; struct Bar { // void a(const Bar\u0026amp; this_, int) { // const Bar* this = \u0026amp;this_; // } // // or just: // // void a(const Bar* this, int); void a(int) const; // void a(Bar\u0026amp; this_, int) { // Bar* this = \u0026amp;this_; // } // // or just: // // void a(Bar* this, int); void a(int); // bar.a(1) -\u0026gt; Bar::a(bar, 1) // // or: // // bar.a(1) -\u0026gt; Bar::a(\u0026amp;bar, 1) }; 带有引用的成员函数无法和不带有引用的成员函数重载在一起，也就是你要么选择 Foo 演示的这一组，要么选择 Bar 演示的这一组。一些其他可能的重载，如带有 volatile 的，就不再写出了。\n从这个例子你也可以再一次看到 C++ 的引用设计得多么失败。\ntypedef 与 using 前文已经有 typedef 和 using 的例子了。typedef 的语法其实很简单，和定义变量是完全一致的。而 using 语法的区别仅仅在于把类型名的部分提到了左边。下面这个例子中，foo_t 和 bar_t 都和 func_ptr 的类型一致。\nint (*func_ptr)(int); typedef int (*foo_t)(int); using bar_t = int(*)(int); using 相比 typedef 的一个优势是可以直接定义「别名模板」（alias template），如：\ntemplate\u0026lt;typename T\u0026gt; using foo_t = std::vector\u0026lt;T\u0026gt;; foo_t\u0026lt;int\u0026gt; foo; 在 C++11 以前，这种需求可以通过套一层 struct 或 class 实现，如：\ntemplate\u0026lt;typename T\u0026gt; struct Bar { typedef std::vector\u0026lt;T\u0026gt; type; }; Bar\u0026lt;int\u0026gt;::type bar; 本文仅讨论类型，所以 using 的其他语义就略过了。\n更多 C++ 的声明语句构成部分相当复杂，并非只有「类型说明符」和「声明符」，但其余部分相比上文提到的那些已经相当人类友好了，没有多少学习障碍，而且其中的很多与类型无关。有兴趣了解的可以参阅 cppreference。\n类型本可以明确易读，只是 C 和 C++ 设计得很失败。既然读到这里了，那么恭喜你解决了一个其他语言不存在的问题。\n","permalink":"https://blog.quarticcat.com/zh/posts/read-cpp-types/","summary":"C++ 的类型可读性很差，并且大多数入门材料中并没有详细介绍如何阅读它们，最多只是讲到 top-level const 和 low-level const 的区别。有不少朋友问过我这方面的问题，讲得多了，干脆整理起来写篇文章。\n常见误解 在详细讲类型的阅读之前，需要纠正一个常见的误解。\n问：int a[5] 里的 a 是什么类型的？\n答：int[5] 类型，在适当的时候会「退化」（decay）成为 int* 类型。\n问：int a[5][6] 里的 a 是什么类型的？\n答：int[5][6] 类型，在适当的时候会「退化」成为 int(*)[6] 类型，即指向 int[6] 的指针。\n由于「退化」这种隐式转换的存在，很多初学 C++ 的人会把数组类型等同于指针类型。\n类似的，函数类型也会「退化」到指针类型，如 int(int, int) 会「退化」成为 int(*)(int, int)。\n解方程 当你查阅如何阅读一些复杂的类型时，你可能会看到网络上一些人说 C++ 的类型就是解方程，让我来详细解释一下这句话。\n抛去 CVR (const, volatile, reference) 等不谈，C++ 最基本的声明分为两个部分：写在最左边的类型名是「类型说明符」（type specifier），剩下的部分是「声明符」（declarator）。这部分内容是从 C 继承过来的，它们是 C++ 类型里最恶心的地方。但这两个名字实在没啥识别度，我喜欢不严谨地称呼为返回值类型和调用表达式，这点后面会解释。先来看几个例子吧：\n声明 类型说明符 声明符 int a int a int* a int *a int a[5] int a[5] int* a[5] int *a[5] int (*a)[5] int (*a)[5] 作出这种分别后，就可以理解上表中a的类型是怎样决定的了：以「声明符」的形式调用a后，得到的返回值类型为「类型说明符」。所谓的解方程就是这样一个过程：","title":"C++ 类型阅读入门"}]