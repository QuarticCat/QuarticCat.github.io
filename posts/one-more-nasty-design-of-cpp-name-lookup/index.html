<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>One more nasty design of C++'s name lookup | QuarticCat's Blog</title>
<meta name=keywords content="cpp"><meta name=description content="As we all know that C++&rsquo;s name lookup has always been extremely counter-intuitive. The infamous argument-dependent lookup (ADL), for example, often leads to unexpected behavior and, worse yet, is often difficult to troubleshoot. This can happen when you define a function in your current namespace, but when you call it the compiler selects another function with the same name thousands of miles away, even though you did not using that foreign function in the current namespace."><meta name=author content="QuarticCat"><link rel=canonical href=https://blog.quarticcat.com/posts/one-more-nasty-design-of-cpp-name-lookup/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.quarticcat.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.quarticcat.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.quarticcat.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.quarticcat.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.quarticcat.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://blog.quarticcat.com/zh/posts/one-more-nasty-design-of-cpp-name-lookup/><link rel=alternate hreflang=en href=https://blog.quarticcat.com/posts/one-more-nasty-design-of-cpp-name-lookup/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "f4a0d5ded0bc48e19ea90f852a11cb57"}'></script><meta property="og:title" content="One more nasty design of C++'s name lookup"><meta property="og:description" content="As we all know that C++&rsquo;s name lookup has always been extremely counter-intuitive. The infamous argument-dependent lookup (ADL), for example, often leads to unexpected behavior and, worse yet, is often difficult to troubleshoot. This can happen when you define a function in your current namespace, but when you call it the compiler selects another function with the same name thousands of miles away, even though you did not using that foreign function in the current namespace."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.quarticcat.com/posts/one-more-nasty-design-of-cpp-name-lookup/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-23T00:00:00+00:00"><meta property="article:modified_time" content="2021-06-23T00:00:00+00:00"><meta property="og:site_name" content="QuarticCat's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="One more nasty design of C++'s name lookup"><meta name=twitter:description content="As we all know that C++&rsquo;s name lookup has always been extremely counter-intuitive. The infamous argument-dependent lookup (ADL), for example, often leads to unexpected behavior and, worse yet, is often difficult to troubleshoot. This can happen when you define a function in your current namespace, but when you call it the compiler selects another function with the same name thousands of miles away, even though you did not using that foreign function in the current namespace."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.quarticcat.com/posts/"},{"@type":"ListItem","position":2,"name":"One more nasty design of C++'s name lookup","item":"https://blog.quarticcat.com/posts/one-more-nasty-design-of-cpp-name-lookup/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"One more nasty design of C++'s name lookup","name":"One more nasty design of C\u002b\u002b\u0027s name lookup","description":"As we all know that C++\u0026rsquo;s name lookup has always been extremely counter-intuitive. The infamous argument-dependent lookup (ADL), for example, often leads to unexpected behavior and, worse yet, is often difficult to troubleshoot. This can happen when you define a function in your current namespace, but when you call it the compiler selects another function with the same name thousands of miles away, even though you did not using that foreign function in the current namespace.","keywords":["cpp"],"articleBody":"As we all know that C++’s name lookup has always been extremely counter-intuitive. The infamous argument-dependent lookup (ADL), for example, often leads to unexpected behavior and, worse yet, is often difficult to troubleshoot. This can happen when you define a function in your current namespace, but when you call it the compiler selects another function with the same name thousands of miles away, even though you did not using that foreign function in the current namespace. Here are two typical examples.\nnamespace fuckadl { struct Fuck {}; void foo(Fuck) { puts(\"not mine\"); } } // namespace fuckadl // case 1 void foo(fuckadl::Fuck) { puts(\"mine\"); } // // case 2 // template // void foo(T) { puts(\"mine\"); } int main() { foo(fuckadl::Fuck{}); } In case 1, you will get a compilation error, which complains about ambiguity. In case 2, which is worse, you won’t even receive a warning. The compiler will simply select fuckadl::foo for you. If you are a beginner of C++, it is likely to take you a whole day to debug this problem.\nThis design directly breaks the encapsulation of namespaces, while countless header-only libraries are using namespaces to hide internal symbols from caller sites (after all, C++’s module mechanism has been delayed for so long), and you don’t know when you’ll collide with someone else’s function names.\nI recently discovered another nasty design of C++’s name lookup. Here it is, C++ Standard Draft N3337 10.2 Member name lookup [class.member.lookup]:\nMember name lookup determines the meaning of a name (id-expression) in a class scope (3.3.7). Name lookup can result in an ambiguity, in which case the program is ill-formed. For an id-expression, name lookup begins in the class scope of this; for a qualified-id, name lookup begins in the scope of the nested-name-specifier. Name lookup takes place before access control (3.4, Clause 11). The last sentence is the main point. It means that access specifiers like public and private are invisible when performing the name lookup. I’ll give a very counter-intuitive case (modified from this question):\nstruct Base { operator bool() { return true; } }; struct Derived: private Base { operator int() { return 1; } }; int main() { std::cout \u003c\u003c Derived{}; } Note the use of private inheritance here. To put it informally, the Derived class actually looks like this from the callers’ perspective:\nstruct Derived { public: operator int() { return 1; } private: operator bool() { return true; } }; However, the compiler will emit an ambiguity error for this code! Because the compiler doesn’t see access specifiers at this point, both operator bool() and operator int() are valid candidates, and that’s why we have ambiguity.\nSince C++ does not have zero-sized types, before the advent of [[no_unique_address]] in C++20, one common way to introduce zero-sized members was to use private / protected inheritance, utilizing the empty base optimization to achieve zero size. This is not rare in template libraries. For example, Boost’s compressed_pair is implemented in this way.\nThanks to this bizarre design, we have to consider whether the names of all members of the base class will conflict with the derived class when using this technique, even if the inheritance is private. This is so outrageous that it could definitely be considered an abstraction leak.\nWait, you say you don’t use private inheritance at all? Well, it can still haunt you. Here’s a simpler example:\nstruct Base1 { public: int x = 1; }; struct Base2 { private: int x = 1; }; struct Derived: Base1, Base2 {}; int main() { Derived{}.x; } The compiler will emit an ambiguity error for this code as well for the same reason. When looking for .x, the compiler doesn’t see access specifiers. It finds that both Base1 and Base2 have an x member, which is ambiguous.\nThis example is a bit more outrageous than the last one. Imagine that, if Base2 come from outside, you won’t even see such a member name in its API document. And most likely the name of this member name is not guaranteed. After all, it’s implementation details. Yet this member will get in the way of your name lookup! Similar to ADL, this design makes private encapsulate nothing.\nOf course, also similar to ADL, there are approaches to get around this. Below is one possible solution. But the existence of this problem is really annoying.\nstruct Derived: Base1, Base2 { using Base1::x; }; Next is the most outrageous thing: ambiguity errors can trigger substitution failures, so they can be used in SFINAE or Concept. That means, by utilizing the code logic above, we can detect externally whether a class has some private / protected members.\nLet me demonstrate it. Suppose we are going to detect member x, no matter whether it is public or not, then we can construct a class A with a member x and a class B that inherits both A and the class to be detected, and then produce a substitution failure by accessing the x member of B. The code is as follows:\nstruct A { int x; }; template\u003cclass T\u003e struct B: A, T {}; template\u003cclass T\u003e concept TestX = !requires(B\u003cT\u003e b) { b.x; }; Lastly, we write two simple test cases.\nstruct HasX { private: int x; }; struct HasY { private: int y; }; static_assert(TestX\u003cHasX\u003e); // success static_assert(TestX\u003cHasY\u003e); // error ","wordCount":"891","inLanguage":"en","datePublished":"2021-06-23T00:00:00Z","dateModified":"2021-06-23T00:00:00Z","author":{"@type":"Person","name":"QuarticCat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.quarticcat.com/posts/one-more-nasty-design-of-cpp-name-lookup/"},"publisher":{"@type":"Organization","name":"QuarticCat's Blog","logo":{"@type":"ImageObject","url":"https://blog.quarticcat.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.quarticcat.com/ accesskey=h title="Home (Alt + H)"><img src=https://blog.quarticcat.com/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.quarticcat.com/zh/ title=中文 aria-label=中文>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://blog.quarticcat.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://blog.quarticcat.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.quarticcat.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.quarticcat.com/blogroll/ title=Blogroll><span>Blogroll</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">One more nasty design of C++'s name lookup</h1><div class=post-meta><span title='2021-06-23 00:00:00 +0000 UTC'>June 23, 2021</span>&nbsp;·&nbsp;QuarticCat&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://blog.quarticcat.com/zh/posts/one-more-nasty-design-of-cpp-name-lookup/>Zh</a></li></ul></div></header><div class=post-content><p>As we all know that C++&rsquo;s name lookup has always been extremely counter-intuitive. The infamous <a href=https://en.cppreference.com/w/cpp/language/adl>argument-dependent lookup (ADL)</a>, for example, often leads to unexpected behavior and, worse yet, is often difficult to troubleshoot. This can happen when you define a function in your current namespace, but when you call it the compiler selects another function with the same name thousands of miles away, even though you did not <code>using</code> that foreign function in the current namespace. Here are two typical examples.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>namespace</span> fuckadl {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Fuck</span> {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>foo</span>(Fuck) { puts(<span style=color:#e6db74>&#34;not mine&#34;</span>); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}  <span style=color:#75715e>// namespace fuckadl
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// case 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>foo</span>(fuckadl<span style=color:#f92672>::</span>Fuck) { puts(<span style=color:#e6db74>&#34;mine&#34;</span>); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// // case 2
</span></span></span><span style=display:flex><span><span style=color:#75715e>// template&lt;class T&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>// void foo(T) { puts(&#34;mine&#34;); }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    foo(fuckadl<span style=color:#f92672>::</span>Fuck{});
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In case 1, you will get a compilation error, which complains about ambiguity. In case 2, which is worse, you won&rsquo;t even receive a warning. The compiler will simply select <code>fuckadl::foo</code> for you. If you are a beginner of C++, it is likely to take you a whole day to debug this problem.</p><p>This design directly breaks the encapsulation of namespaces, while countless header-only libraries are using namespaces to hide internal symbols from caller sites (after all, C++&rsquo;s module mechanism has been delayed for so long), and you don&rsquo;t know when you&rsquo;ll collide with someone else&rsquo;s function names.</p><p>I recently discovered another nasty design of C++&rsquo;s name lookup. Here it is, C++ Standard Draft N3337 10.2 Member name lookup [class.member.lookup]:</p><blockquote><ol><li>Member name lookup determines the meaning of a name (id-expression) in a class scope (3.3.7). Name lookup can result in an ambiguity, in which case the program is ill-formed. For an id-expression, name lookup begins in the class scope of this; for a qualified-id, name lookup begins in the scope of the nested-name-specifier. <strong>Name lookup takes place before access control</strong> (3.4, Clause 11).</li></ol></blockquote><p>The last sentence is the main point. It means that access specifiers like <code>public</code> and <code>private</code> are invisible when performing the name lookup. I&rsquo;ll give a very counter-intuitive case (modified from <a href=https://stackoverflow.com/questions/21636150/typecast-operator-in-private-base>this question</a>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Base</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>operator</span> <span style=color:#a6e22e>bool</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Derived</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>private</span> Base {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>operator</span> <span style=color:#a6e22e>int</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> Derived{};
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Note the use of <code>private</code> inheritance here. To put it informally, the <code>Derived</code> class actually looks like this from the callers&rsquo; perspective:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Derived</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>operator</span> <span style=color:#66d9ef>int</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>operator</span> <span style=color:#66d9ef>bool</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>However, the compiler will emit an ambiguity error for this code! Because the compiler doesn&rsquo;t see access specifiers at this point, both <code>operator bool()</code> and <code>operator int()</code> are valid candidates, and that&rsquo;s why we have ambiguity.</p><p>Since C++ does not have zero-sized types, before the advent of <code>[[no_unique_address]]</code> in C++20, one common way to introduce zero-sized members was to use <code>private</code> / <code>protected</code> inheritance, utilizing the <a href=https://en.cppreference.com/w/cpp/language/ebo>empty base optimization</a> to achieve zero size. This is not rare in template libraries. For example, Boost&rsquo;s <a href=https://theboostcpplibraries.com/boost.compressed_pair><code>compressed_pair</code></a> is implemented in this way.</p><p>Thanks to this bizarre design, we have to consider whether the names of all members of the base class will conflict with the derived class when using this technique, even if the inheritance is <code>private</code>. This is so outrageous that it could definitely be considered an abstraction leak.</p><p>Wait, you say you don&rsquo;t use <code>private</code> inheritance at all? Well, it can still haunt you. Here&rsquo;s a simpler example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Base1</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Base2</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Derived</span><span style=color:#f92672>:</span> Base1, Base2 {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Derived{}.x;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The compiler will emit an ambiguity error for this code as well for the same reason. When looking for <code>.x</code>, the compiler doesn&rsquo;t see access specifiers. It finds that both <code>Base1</code> and <code>Base2</code> have an <code>x</code> member, which is ambiguous.</p><p>This example is a bit more outrageous than the last one. Imagine that, if <code>Base2</code> come from outside, you won&rsquo;t even see such a member name in its API document. And most likely the name of this member name is not guaranteed. After all, it&rsquo;s implementation details. Yet this member will get in the way of your name lookup! Similar to ADL, this design makes <code>private</code> encapsulate nothing.</p><p>Of course, also similar to ADL, there are approaches to get around this. Below is one possible solution. But the existence of this problem is really annoying.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Derived</span><span style=color:#f92672>:</span> Base1, Base2 {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> Base1<span style=color:#f92672>::</span>x;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Next is the most outrageous thing: ambiguity errors can trigger substitution failures, so they can be used in SFINAE or Concept. That means, by utilizing the code logic above, we can detect externally whether a class has some <code>private</code> / <code>protected</code> members.</p><p>Let me demonstrate it. Suppose we are going to detect member <code>x</code>, no matter whether it is <code>public</code> or not, then we can construct a class <code>A</code> with a member <code>x</code> and a class <code>B</code> that inherits both <code>A</code> and the class to be detected, and then produce a substitution failure by accessing the <code>x</code> member of <code>B</code>. The code is as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>A</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>B</span><span style=color:#f92672>:</span> A, T {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>concept</span> TestX <span style=color:#f92672>=</span> <span style=color:#f92672>!</span><span style=color:#66d9ef>requires</span>(B<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> b) {
</span></span><span style=display:flex><span>    b.x;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Lastly, we write two simple test cases.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>HasX</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>HasY</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> y;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static_assert</span>(TestX<span style=color:#f92672>&lt;</span>HasX<span style=color:#f92672>&gt;</span>);  <span style=color:#75715e>// success
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static_assert</span>(TestX<span style=color:#f92672>&lt;</span>HasY<span style=color:#f92672>&gt;</span>);  <span style=color:#75715e>// error
</span></span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.quarticcat.com/tags/cpp/>Cpp</a></li></ul><nav class=paginav><a class=prev href=https://blog.quarticcat.com/posts/rvv-may-not-be-as-good-as-you-think/><span class=title>« Prev</span><br><span>RVV may not be as good as you think</span>
</a><a class=next href=https://blog.quarticcat.com/posts/read-cpp-types/><span class=title>Next »</span><br><span>How to read C++ types</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.quarticcat.com/>QuarticCat's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>