<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>No more OOM in C/C++/Rust builds | QuarticCat's Blog</title>
<meta name=keywords content="cpp,rust,optimization"><meta name=description content="I&rsquo;ve seen people complaining about some gigantic C/C++/Rust projects engulfing all of their memory during building from time to time. Fortunately, there are a few simple methods to alleviate the pain without sacrificing speed. By &ldquo;simple,&rdquo; I mean you don&rsquo;t have to modify your code!
Root of the problem Usually, the most memory-consuming part of C/C++/Rust builds is the linking phase. To link object files, the linker must read all of them into memory."><meta name=author content="QuarticCat"><link rel=canonical href=https://blog.quarticcat.com/posts/no-more-oom/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.quarticcat.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.quarticcat.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.quarticcat.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.quarticcat.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.quarticcat.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.quarticcat.com/posts/no-more-oom/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "f4a0d5ded0bc48e19ea90f852a11cb57"}'></script><meta property="og:title" content="No more OOM in C/C++/Rust builds"><meta property="og:description" content="I&rsquo;ve seen people complaining about some gigantic C/C++/Rust projects engulfing all of their memory during building from time to time. Fortunately, there are a few simple methods to alleviate the pain without sacrificing speed. By &ldquo;simple,&rdquo; I mean you don&rsquo;t have to modify your code!
Root of the problem Usually, the most memory-consuming part of C/C++/Rust builds is the linking phase. To link object files, the linker must read all of them into memory."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.quarticcat.com/posts/no-more-oom/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-07-02T00:00:00+00:00"><meta property="article:modified_time" content="2024-07-02T00:00:00+00:00"><meta property="og:site_name" content="QuarticCat's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="No more OOM in C/C++/Rust builds"><meta name=twitter:description content="I&rsquo;ve seen people complaining about some gigantic C/C++/Rust projects engulfing all of their memory during building from time to time. Fortunately, there are a few simple methods to alleviate the pain without sacrificing speed. By &ldquo;simple,&rdquo; I mean you don&rsquo;t have to modify your code!
Root of the problem Usually, the most memory-consuming part of C/C++/Rust builds is the linking phase. To link object files, the linker must read all of them into memory."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.quarticcat.com/posts/"},{"@type":"ListItem","position":2,"name":"No more OOM in C/C++/Rust builds","item":"https://blog.quarticcat.com/posts/no-more-oom/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"No more OOM in C/C++/Rust builds","name":"No more OOM in C\/C\u002b\u002b\/Rust builds","description":"I\u0026rsquo;ve seen people complaining about some gigantic C/C++/Rust projects engulfing all of their memory during building from time to time. Fortunately, there are a few simple methods to alleviate the pain without sacrificing speed. By \u0026ldquo;simple,\u0026rdquo; I mean you don\u0026rsquo;t have to modify your code!\nRoot of the problem Usually, the most memory-consuming part of C/C++/Rust builds is the linking phase. To link object files, the linker must read all of them into memory.","keywords":["cpp","rust","optimization"],"articleBody":"I’ve seen people complaining about some gigantic C/C++/Rust projects engulfing all of their memory during building from time to time. Fortunately, there are a few simple methods to alleviate the pain without sacrificing speed. By “simple,” I mean you don’t have to modify your code!\nRoot of the problem Usually, the most memory-consuming part of C/C++/Rust builds is the linking phase. To link object files, the linker must read all of them into memory. As more and more object files are linked together, the memory usage grows quickly.\nWhat’s worse, by default, DWARF embeds all debugging information into object files, which increases file sizes and thus the memory consumption. GCC Wiki mentioned that:\nIn a large C++ application compiled with -O2 and -g, the debug information accounts for 87% of the total size of the object files sent as inputs to the link step, and 84% of the total size of the output binary.\nNinja / CMake In case you haven’t heard about Ninja, it’s a build system similar to Makefile. Different from Makefile, it’s not for hand-writing but for meta build systems like CMake to generate. It’s also much faster than Makefile.\nNinja has a cool feature called pools. Each pool represents a limitation on the number of jobs. You can assign each of your rules to a pool. With this feature, you can limit the number of concurrent linkers, say to no more than four.\nIf you simply use a smaller -j number, the parallelism of compiling jobs will also be limited. Using Ninja’s pools gives you finer control.\nAs I just said, Ninja itself is not for hand-writing. Typically we invoke Ninja through CMake. A good news is that CMake provides two options on top of Ninja: JOB_POOL_COMPILE and JOB_POOL_LINK. It’s quite easy to apply them to your projects.\nMold Mold is the fastest linker in the world. Many people are already aware of that. However, what they may not know is that Mold provides an environment variable MOLD_JOBS to control the parallelism of Mold processes.\nThe primary reason for this environment variable is to minimize peak memory usage. Since mold is designed to operate with high parallelism, running multiple mold instances simultaneously may not be beneficial. If you execute N instances of mold concurrently, it could require N times the time and N times the memory. On the other hand, running them one after the other might still take N times longer, but the peak memory usage would be the same as running just a single instance.\nA single linker instance can hardly cause OOM (Out-of-Memory). And you don’t need to trade speed for this!\nCompared to Ninja’s solution, this one is faster and more widely applicable. Whatever build system and language you are using, just prepend the build command with mold -run. That’s it.\nSplit DWARF DWARF has an extension allowing you to split most debug information into separate .dwo files, and optionally leave index to them in object files to speedup debugging. By doing so, linker’s inputs are largely shrunk, saving you both time and memory.\nTo enable this feature in C/C++ builds, simply add -gsplit-dwarf to your compiler invocations. For example, in CMake you can use CMAKE__FLAGS or corresponding environment variables. To create the index, add -Wl,--gdb-index to your linker invocations.\nFor Rust builds, Cargo has this feature built-in already. Just set split-debuginfo to unpacked in your profile.\n","wordCount":"565","inLanguage":"en","datePublished":"2024-07-02T00:00:00Z","dateModified":"2024-07-02T00:00:00Z","author":{"@type":"Person","name":"QuarticCat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.quarticcat.com/posts/no-more-oom/"},"publisher":{"@type":"Organization","name":"QuarticCat's Blog","logo":{"@type":"ImageObject","url":"https://blog.quarticcat.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.quarticcat.com/ accesskey=h title="Home (Alt + H)"><img src=https://blog.quarticcat.com/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.quarticcat.com/zh/ title=中文 aria-label=中文>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://blog.quarticcat.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://blog.quarticcat.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.quarticcat.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.quarticcat.com/blogroll/ title=Blogroll><span>Blogroll</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">No more OOM in C/C++/Rust builds</h1><div class=post-meta><span title='2024-07-02 00:00:00 +0000 UTC'>July 2, 2024</span>&nbsp;·&nbsp;QuarticCat</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#root-of-the-problem>Root of the problem</a></li><li><a href=#ninja--cmake>Ninja / CMake</a></li><li><a href=#mold>Mold</a></li><li><a href=#split-dwarf>Split DWARF</a></li></ul></nav></div></details></div><div class=post-content><p>I&rsquo;ve seen people complaining about some gigantic C/C++/Rust projects engulfing all of their memory during building from time to time. Fortunately, there are a few simple methods to alleviate the pain without sacrificing speed. By &ldquo;simple,&rdquo; I mean you don&rsquo;t have to modify your code!</p><h2 id=root-of-the-problem>Root of the problem<a hidden class=anchor aria-hidden=true href=#root-of-the-problem>#</a></h2><p>Usually, the most memory-consuming part of C/C++/Rust builds is the linking phase. To link object files, the linker must read all of them into memory. As more and more object files are linked together, the memory usage grows quickly.</p><p>What&rsquo;s worse, by default, DWARF embeds all debugging information into object files, which increases file sizes and thus the memory consumption. <a href=https://gcc.gnu.org/wiki/DebugFission>GCC Wiki</a> mentioned that:</p><blockquote><p>In a large C++ application compiled with -O2 and -g, the debug information accounts for 87% of the total size of the object files sent as inputs to the link step, and 84% of the total size of the output binary.</p></blockquote><h2 id=ninja--cmake>Ninja / CMake<a hidden class=anchor aria-hidden=true href=#ninja--cmake>#</a></h2><p>In case you haven&rsquo;t heard about <a href=https://ninja-build.org/>Ninja</a>, it&rsquo;s a build system similar to Makefile. Different from Makefile, it&rsquo;s not for hand-writing but for meta build systems like CMake to generate. It&rsquo;s also much faster than Makefile.</p><p>Ninja has a cool feature called <a href=https://ninja-build.org/manual.html#ref_pool>pools</a>. Each pool represents a limitation on the number of jobs. You can assign each of your rules to a pool. With this feature, you can limit the number of concurrent linkers, say to no more than four.</p><p>If you simply use a smaller <code>-j</code> number, the parallelism of compiling jobs will also be limited. Using Ninja&rsquo;s pools gives you finer control.</p><p>As I just said, Ninja itself is not for hand-writing. Typically we invoke Ninja through CMake. A good news is that CMake provides two options on top of Ninja: <a href=https://cmake.org/cmake/help/latest/prop_tgt/JOB_POOL_COMPILE.html><code>JOB_POOL_COMPILE</code></a> and <a href=https://cmake.org/cmake/help/latest/prop_tgt/JOB_POOL_LINK.html><code>JOB_POOL_LINK</code></a>. It&rsquo;s quite easy to apply them to your projects.</p><h2 id=mold>Mold<a hidden class=anchor aria-hidden=true href=#mold>#</a></h2><p><a href=https://github.com/rui314/mold>Mold</a> is the fastest linker in the world. Many people are already aware of that. However, what they may not know is that Mold provides an environment variable <a href=https://github.com/rui314/mold/blob/main/docs/mold.md#environment-variables><code>MOLD_JOBS</code></a> to control the parallelism of Mold processes.</p><blockquote><p>The primary reason for this environment variable is to minimize peak memory usage. Since mold is designed to operate with high parallelism, running multiple mold instances simultaneously may not be beneficial. If you execute N instances of mold concurrently, it could require N times the time and N times the memory. On the other hand, running them one after the other might still take N times longer, but the peak memory usage would be the same as running just a single instance.</p></blockquote><p>A single linker instance can hardly cause OOM (Out-of-Memory). And you don&rsquo;t need to trade speed for this!</p><p>Compared to Ninja&rsquo;s solution, this one is faster and more widely applicable. Whatever build system and language you are using, just prepend the build command with <code>mold -run</code>. That&rsquo;s it.</p><h2 id=split-dwarf>Split DWARF<a hidden class=anchor aria-hidden=true href=#split-dwarf>#</a></h2><p>DWARF has an <a href=https://gcc.gnu.org/wiki/DebugFission>extension</a> allowing you to split most debug information into separate <code>.dwo</code> files, and optionally leave index to them in object files to speedup debugging. By doing so, linker&rsquo;s inputs are largely shrunk, saving you both time and memory.</p><p>To enable this feature in C/C++ builds, simply add <code>-gsplit-dwarf</code> to your compiler invocations. For example, in CMake you can use <a href=https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_FLAGS.html><code>CMAKE_&lt;LANG>_FLAGS</code></a> or corresponding environment variables. To create the index, add <code>-Wl,--gdb-index</code> to your linker invocations.</p><p>For Rust builds, Cargo has this feature built-in already. Just set <a href=https://doc.rust-lang.org/cargo/reference/profiles.html#split-debuginfo><code>split-debuginfo</code></a> to <code>unpacked</code> in your profile.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.quarticcat.com/tags/cpp/>Cpp</a></li><li><a href=https://blog.quarticcat.com/tags/rust/>Rust</a></li><li><a href=https://blog.quarticcat.com/tags/optimization/>Optimization</a></li></ul><nav class=paginav><a class=next href=https://blog.quarticcat.com/posts/some-useful-zsh-key-bindings/><span class=title>Next »</span><br><span>Some useful Zsh key-bindings</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.quarticcat.com/>QuarticCat's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>