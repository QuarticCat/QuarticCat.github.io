<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Some useful Zsh key-bindings | QuarticCat's Blog</title>
<meta name=keywords content="zsh"><meta name=description content="Built-in undo & redo No need to explain. They work as their name suggest. Many Zsh users remain unaware of these two widgets since they are not bound in viins keymap (which is the default for most users). I bind them to [Ctrl+Z] & [Ctrl+Y], respectively.
magic-space It behaves like normal space except that it can perform history expansion. That is to say, it turns !-1 to <last command> in your buffer."><meta name=author content="QuarticCat"><link rel=canonical href=https://blog.quarticcat.com/posts/some-useful-zsh-key-bindings/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.quarticcat.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.quarticcat.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.quarticcat.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.quarticcat.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.quarticcat.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.quarticcat.com/posts/some-useful-zsh-key-bindings/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "f4a0d5ded0bc48e19ea90f852a11cb57"}'></script><meta property="og:title" content="Some useful Zsh key-bindings"><meta property="og:description" content="Built-in undo & redo No need to explain. They work as their name suggest. Many Zsh users remain unaware of these two widgets since they are not bound in viins keymap (which is the default for most users). I bind them to [Ctrl+Z] & [Ctrl+Y], respectively.
magic-space It behaves like normal space except that it can perform history expansion. That is to say, it turns !-1 to <last command> in your buffer."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.quarticcat.com/posts/some-useful-zsh-key-bindings/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-12T00:00:00+00:00"><meta property="article:modified_time" content="2024-03-12T00:00:00+00:00"><meta property="og:site_name" content="QuarticCat's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Some useful Zsh key-bindings"><meta name=twitter:description content="Built-in undo & redo No need to explain. They work as their name suggest. Many Zsh users remain unaware of these two widgets since they are not bound in viins keymap (which is the default for most users). I bind them to [Ctrl+Z] & [Ctrl+Y], respectively.
magic-space It behaves like normal space except that it can perform history expansion. That is to say, it turns !-1 to <last command> in your buffer."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.quarticcat.com/posts/"},{"@type":"ListItem","position":2,"name":"Some useful Zsh key-bindings","item":"https://blog.quarticcat.com/posts/some-useful-zsh-key-bindings/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Some useful Zsh key-bindings","name":"Some useful Zsh key-bindings","description":"Built-in undo \u0026amp; redo No need to explain. They work as their name suggest. Many Zsh users remain unaware of these two widgets since they are not bound in viins keymap (which is the default for most users). I bind them to [Ctrl+Z] \u0026amp; [Ctrl+Y], respectively.\nmagic-space It behaves like normal space except that it can perform history expansion. That is to say, it turns !-1 to \u0026lt;last command\u0026gt; in your buffer.","keywords":["zsh"],"articleBody":"Built-in undo \u0026 redo No need to explain. They work as their name suggest. Many Zsh users remain unaware of these two widgets since they are not bound in viins keymap (which is the default for most users). I bind them to [Ctrl+Z] \u0026 [Ctrl+Y], respectively.\nmagic-space It behaves like normal space except that it can perform history expansion. That is to say, it turns !-1 to in your buffer. Usually bound to [Space].\npush-line Push the current buffer onto the buffer stack and clear the buffer. Next time the editor starts up, the buffer will be popped off the top of the buffer stack and loaded into the editing buffer.\nIt allows you to leave halfway to execute one other command and then resume. Usually bound to [Ctrl+Q].\npush-line-or-edit At the top-level (PS1) prompt, equivalent to push-line. At a secondary (PS2) prompt, move the entire current multiline construct into the editor buffer. The latter is equivalent to push-input followed by get-line.\nA more powerful version of push-line. Usually bound to [Ctrl+Q].\nIf you want to learn more, there are a few good places to go:\nhttps://zsh.sourceforge.io/Doc/Release/Zsh-Line-Editor.html https://github.com/zsh-users/zsh/tree/master/Functions/Zle Mine Word movement # Ref: https://github.com/marlonrichert/zsh-edit qc-word-widgets() { if [[ $WIDGET == *-shellword ]] { local words=(${(Z:n:)BUFFER}) lwords=(${(Z:n:)LBUFFER}) if [[ $WIDGET == *-backward-* ]] { local tail=$lwords[-1] local move=-${(N)LBUFFER%$tail*} } else { local head=${${words[$#lwords]#$lwords[-1]}:-$words[$#lwords+1]} local move=+${(N)RBUFFER#*$head} } } else { local subword='([[:WORD:]]##~*[^[:upper:]]*[[:upper:]]*~*[[:alnum:]]*[^[:alnum:]]*)' local word=\"(${subword}|[^[:WORD:][:space:]]##|[[:space:]]##)\" if [[ $WIDGET == *-backward-* ]] { local move=-${(N)LBUFFER%%${~word}(?|)} } else { local move=+${(N)RBUFFER##(?|)${~word}} } } if [[ $WIDGET == *-kill-* ]] { (( MARK = CURSOR + move )) zle -f kill zle .kill-region } else { (( CURSOR += move )) } } for w in qc-{back,for}ward-{,kill-}{sub,shell}word; zle -N $w qc-word-widgets bindkey '^[[1;5D' qc-backward-subword # [Ctrl+Left] bindkey '^[[1;5C' qc-forward-subword # [Ctrl+Right] bindkey '^[[1;3D' qc-backward-shellword # [Alt+Left] bindkey '^[[1;3C' qc-forward-shellword # [Alt+Right] bindkey '^H' qc-backward-kill-subword # [Ctrl+Backspace] (in Konsole) bindkey '^W' qc-backward-kill-subword # [Ctrl+Backspace] (in VSCode) bindkey '^[[3;5~' qc-forward-kill-subword # [Ctrl+Delete] bindkey '^[^?' qc-backward-kill-shellword # [Alt+Backspace] bindkey '^[[3;3~' qc-forward-kill-shellword # [Alt+Delete] zsh-edit’s README explains the effect very well:\nThis is how built-in word widgets ({for,back}ward-word, {,backward-}-kill-word) move:\n# Zsh with default WORDCHARS='*?_-.[]~=/\u0026;!#$%^(){}\u003c\u003e' moves/deletes way too much: # \u003e \u003e \u003e \u003e \u003e % ENV_VAR=value command --option-flag camelCaseWord ~/dir/*.ext # \u003c \u003c \u003c \u003c \u003c # Zsh with WORDCHARS='' is bit better, but skips punctuation clusters \u0026 doesn't find subWords: # \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e % ENV_VAR=value command --option-flag camelCaseWord ~/dir/*.ext # \u003c \u003c \u003c \u003c \u003c \u003c \u003c \u003c \u003c This is how zsh-edit subword widgets move:\n# Zsh Edit with WORDCHARS='' # \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e % ENV_VAR=value command --option-flag camelCaseWord ~/dir/?*.ext # \u003c \u003c \u003c \u003c \u003c \u003c \u003c \u003c \u003c \u003c \u003c \u003c \u003c # Zsh Edit with WORDCHARS='~*?' # \u003e \u003e \u003e \u003e \u003e % cd ~/dir/?*.ext # \u003c \u003c \u003c \u003c \u003c This function also includes shell-word widgets to let you move with greater strides. They are more intuitive than Zsh’s select-word-style in some edge cases.\nAccept line Update 2024-03-12: I find that Roman Perepelitsa has made an excellent plugin called zsh-no-ps2 for this purpose. It’s more thoughtful and rigorous than my widget.\n# [Enter] Insert `\\n` when accept-line would result in a parse error or PS2 # Ref: https://github.com/romkatv/zsh4humans/blob/v5/fn/z4h-accept-line qc-accept-line() { if [[ $(functions[_qc-test]=$BUFFER 2\u003e\u00261) == '' ]] { zle .accept-line } else { LBUFFER+=$'\\n' } } zle -N qc-accept-line bindkey '^M' qc-accept-line On occasion, we may unintentionally hit a key – like ' – before hitting enter. And that will result in a secondary prompt (PS2), which is poorly supported, and your first line will be recorded in history anyway.\nIn contrast, my widget gives you a newline instead in that scenario, so you can just delete back to correct your command. Moreover, my widget makes writing multi-line commands easier.\nTrim paste # Trim trailing whitespace from pasted text # Ref: https://unix.stackexchange.com/questions/693118 qc-trim-paste() { zle .bracketed-paste LBUFFER=${LBUFFER%%[[:space:]]#} } zle -N bracketed-paste qc-trim-paste Sometimes, we want to copy some command from the browser, say:\necho 'hello world' We triple-click it to select the whole line and then copy. However, triple-clicking also selects the newline character. This could be annoying when pasting to the terminal. Have a try!\nThankfully, we have bracketed-paste handling all pasted text. We can hook pasting by overwriting this widget. The same trick is used by bracketed-paste-magic and bracketed-paste-url-magic.\nRationalize dot # Change `...` to `../..` # Ref: https://grml.org/zsh/zsh-lovers.html#_completion qc-rationalize-dot() { if [[ $LBUFFER == *.. ]] { LBUFFER+='/..' } else { LBUFFER+='.' } } zle -N qc-rationalize-dot bindkey '.' qc-rationalize-dot bindkey '^[.' self-insert-unmeta # [Alt+.] insert dot It’s a better alternative to traditional .../..../..... aliases. It’s more readable and supports unlimited levels.\nClear screen # [Ctrl+L] Clear screen but keep scrollback # Ref: https://superuser.com/questions/1389834 qc-clear-screen() { local prompt_height=$(echo -n ${(%%)PS1} | wc -l) local lines=$((LINES - prompt_height)) printf \"$terminfo[cud1]%.0s\" {1..$lines} # cursor down printf \"$terminfo[cuu1]%.0s\" {1..$lines} # cursor up zle .reset-prompt } zle -N qc-clear-screen bindkey '^L' qc-clear-screen Zsh has a built-in clear-screen widget bound to [Ctrl+L] by default. But it also erases your terminal emulator’s whole history in addition to the screen. My widget can keep the scrollback.\nAnd it’s more flexible. You can customize prompt position by adjusting the number of lines. For example, local lines=$((LINES/2)) moves the prompt to the middle.\nFuck # [Esc Esc] Correct previous command # Ref: https://github.com/ohmyzsh/ohmyzsh/blob/master/plugins/thefuck qc-fuck() { local fuck=$(THEFUCK_REQUIRE_CONFIRMATION=false thefuck $(fc -ln -1) 2\u003e/dev/null) if [[ $fuck != '' ]] { compadd -Q $fuck } else { compadd -x '%F{red}-- no fucks given --%f' } } zle -C qc-fuck complete-word qc-fuck bindkey '\\e\\e' qc-fuck It’s a powerful replacement of oh-my-zsh’s sudo plugin. It calls thefuck to correct previous command. There are many cases that sudo plugin cannot handle, for example:\necho 1 \u003e /sys/devices/system/cpu/cpufreq/boost You can’t simply prefix it with sudo as echo is not a program but a shell built-in command. Now, thefuck to the rescue. It can smartly prompt sudo sh -c \"echo 1 \u003e /sys/devices/system/cpu/cpufreq/boost\".\nIt’s better than using fuck as well. Because you can edit the command before executing it.\nMore Here are some key-bindings that aren’t up my street but are still useful.\nfzf fzf is a fuzzy finder. It can be integrated to many commands to provide a handy selection menu. fzf offers some completions and key-bindings under the shell folder. For Zsh, that includes:\n[Ctrl+T] - Paste the selected file path(s) into the command line [Alt+C] - cd into the selected directory [Ctrl+R] - Paste the selected command from history into the command line I also recommend you to take a look at fzf-tab, a fabulous completion plugin.\nxplr xplr is a TUI file explorer. Its document offers a bunch of hacks. I used to enjoy this key-binding:\n# [Ctrl+N] Navigate by xplr # This is not a widget since properly resetting prompt is hard # See https://github.com/romkatv/powerlevel10k/issues/72 bindkey -s '^N' '^Q cd -- $(xplr --print-pwd-as-result) \\n' I’ve spent enough time on this blog. There are more awesome projects but I’m too lazy to introduce all of them. Some are listed below.\nmouse.zsh zce.zsh mcfly atuin ","wordCount":"1190","inLanguage":"en","datePublished":"2024-03-12T00:00:00Z","dateModified":"2024-03-12T00:00:00Z","author":{"@type":"Person","name":"QuarticCat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.quarticcat.com/posts/some-useful-zsh-key-bindings/"},"publisher":{"@type":"Organization","name":"QuarticCat's Blog","logo":{"@type":"ImageObject","url":"https://blog.quarticcat.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.quarticcat.com/ accesskey=h title="Home (Alt + H)"><img src=https://blog.quarticcat.com/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.quarticcat.com/zh/ title=中文 aria-label=中文>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://blog.quarticcat.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://blog.quarticcat.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.quarticcat.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.quarticcat.com/blogroll/ title=Blogroll><span>Blogroll</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Some useful Zsh key-bindings</h1><div class=post-meta><span title='2024-03-12 00:00:00 +0000 UTC'>March 12, 2024</span>&nbsp;·&nbsp;QuarticCat</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#built-in>Built-in</a><ul><li><a href=#undo--redo><code>undo</code> & <code>redo</code></a></li><li><a href=#magic-space><code>magic-space</code></a></li><li><a href=#push-line><code>push-line</code></a></li><li><a href=#push-line-or-edit><code>push-line-or-edit</code></a></li></ul></li><li><a href=#mine>Mine</a><ul><li><a href=#word-movement>Word movement</a></li><li><a href=#accept-line>Accept line</a></li><li><a href=#trim-paste>Trim paste</a></li><li><a href=#rationalize-dot>Rationalize dot</a></li><li><a href=#clear-screen>Clear screen</a></li><li><a href=#fuck>Fuck</a></li></ul></li><li><a href=#more>More</a><ul><li><a href=#fzf>fzf</a></li><li><a href=#xplr>xplr</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=built-in>Built-in<a hidden class=anchor aria-hidden=true href=#built-in>#</a></h2><h3 id=undo--redo><code>undo</code> & <code>redo</code><a hidden class=anchor aria-hidden=true href=#undo--redo>#</a></h3><p>No need to explain. They work as their name suggest. Many Zsh users remain unaware of these two widgets since they are not bound in <code>viins</code> keymap (which is the default for most users). I bind them to <code>[Ctrl+Z]</code> & <code>[Ctrl+Y]</code>, respectively.</p><h3 id=magic-space><code>magic-space</code><a hidden class=anchor aria-hidden=true href=#magic-space>#</a></h3><p>It behaves like normal space except that it can perform <a href=https://zsh.sourceforge.io/Doc/Release/Expansion.html#History-Expansion>history expansion</a>. That is to say, it turns <code>!-1</code> to <code>&lt;last command> </code>in your buffer. Usually bound to <code>[Space]</code>.</p><h3 id=push-line><code>push-line</code><a hidden class=anchor aria-hidden=true href=#push-line>#</a></h3><blockquote><p>Push the current buffer onto the buffer stack and clear the buffer. Next time the editor starts up, the buffer will be popped off the top of the buffer stack and loaded into the editing buffer.</p></blockquote><p>It allows you to leave halfway to execute one other command and then resume. Usually bound to <code>[Ctrl+Q]</code>.</p><h3 id=push-line-or-edit><code>push-line-or-edit</code><a hidden class=anchor aria-hidden=true href=#push-line-or-edit>#</a></h3><blockquote><p>At the top-level (PS1) prompt, equivalent to push-line. At a secondary (PS2) prompt, move the entire current multiline construct into the editor buffer. The latter is equivalent to push-input followed by get-line.</p></blockquote><p>A more powerful version of <code>push-line</code>. Usually bound to <code>[Ctrl+Q]</code>.</p><p>If you want to learn more, there are a few good places to go:</p><ul><li><a href=https://zsh.sourceforge.io/Doc/Release/Zsh-Line-Editor.html>https://zsh.sourceforge.io/Doc/Release/Zsh-Line-Editor.html</a></li><li><a href=https://github.com/zsh-users/zsh/tree/master/Functions/Zle>https://github.com/zsh-users/zsh/tree/master/Functions/Zle</a></li></ul><h2 id=mine>Mine<a hidden class=anchor aria-hidden=true href=#mine>#</a></h2><h3 id=word-movement>Word movement<a hidden class=anchor aria-hidden=true href=#word-movement>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span><span style=color:#75715e># Ref: https://github.com/marlonrichert/zsh-edit</span>
</span></span><span style=display:flex><span>qc-word-widgets<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[[</span> $WIDGET <span style=color:#f92672>==</span> *-shellword <span style=color:#f92672>]]</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        local words<span style=color:#f92672>=(</span><span style=color:#e6db74>${</span>(Z:n:)BUFFER<span style=color:#e6db74>}</span><span style=color:#f92672>)</span> lwords<span style=color:#f92672>=(</span><span style=color:#e6db74>${</span>(Z:n:)LBUFFER<span style=color:#e6db74>}</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>[[</span> $WIDGET <span style=color:#f92672>==</span> *-backward-* <span style=color:#f92672>]]</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            local tail<span style=color:#f92672>=</span>$lwords<span style=color:#f92672>[</span>-1<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>            local move<span style=color:#f92672>=</span>-<span style=color:#e6db74>${</span>(N)LBUFFER%$tail*<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            local head<span style=color:#f92672>=</span><span style=color:#e6db74>${${</span>words[$#lwords]#$lwords[-1]<span style=color:#e6db74>}</span><span style=color:#66d9ef>:-</span>$words[$#lwords+1]<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span>            local move<span style=color:#f92672>=</span>+<span style=color:#e6db74>${</span>(N)RBUFFER#*$head<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        local subword<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;([[:WORD:]]##~*[^[:upper:]]*[[:upper:]]*~*[[:alnum:]]*[^[:alnum:]]*)&#39;</span>
</span></span><span style=display:flex><span>        local word<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;(</span><span style=color:#e6db74>${</span>subword<span style=color:#e6db74>}</span><span style=color:#e6db74>|[^[:WORD:][:space:]]##|[[:space:]]##)&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>[[</span> $WIDGET <span style=color:#f92672>==</span> *-backward-* <span style=color:#f92672>]]</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            local move<span style=color:#f92672>=</span>-<span style=color:#e6db74>${</span>(N)LBUFFER%%<span style=color:#e6db74>${</span>~word<span style=color:#e6db74>}</span>(?|)<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            local move<span style=color:#f92672>=</span>+<span style=color:#e6db74>${</span>(N)RBUFFER##(?|)<span style=color:#e6db74>${</span>~word<span style=color:#e6db74>}}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[[</span> $WIDGET <span style=color:#f92672>==</span> *-kill-* <span style=color:#f92672>]]</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>((</span> MARK <span style=color:#f92672>=</span> CURSOR + move <span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>        zle -f kill
</span></span><span style=display:flex><span>        zle .kill-region
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>((</span> CURSOR <span style=color:#f92672>+=</span> move <span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> w in qc-<span style=color:#f92672>{</span>back,for<span style=color:#f92672>}</span>ward-<span style=color:#f92672>{</span>,kill-<span style=color:#f92672>}{</span>sub,shell<span style=color:#f92672>}</span>word; zle -N $w qc-word-widgets
</span></span><span style=display:flex><span>bindkey <span style=color:#e6db74>&#39;^[[1;5D&#39;</span> qc-backward-subword         <span style=color:#75715e># [Ctrl+Left]</span>
</span></span><span style=display:flex><span>bindkey <span style=color:#e6db74>&#39;^[[1;5C&#39;</span> qc-forward-subword          <span style=color:#75715e># [Ctrl+Right]</span>
</span></span><span style=display:flex><span>bindkey <span style=color:#e6db74>&#39;^[[1;3D&#39;</span> qc-backward-shellword       <span style=color:#75715e># [Alt+Left]</span>
</span></span><span style=display:flex><span>bindkey <span style=color:#e6db74>&#39;^[[1;3C&#39;</span> qc-forward-shellword        <span style=color:#75715e># [Alt+Right]</span>
</span></span><span style=display:flex><span>bindkey <span style=color:#e6db74>&#39;^H&#39;</span>      qc-backward-kill-subword    <span style=color:#75715e># [Ctrl+Backspace] (in Konsole)</span>
</span></span><span style=display:flex><span>bindkey <span style=color:#e6db74>&#39;^W&#39;</span>      qc-backward-kill-subword    <span style=color:#75715e># [Ctrl+Backspace] (in VSCode)</span>
</span></span><span style=display:flex><span>bindkey <span style=color:#e6db74>&#39;^[[3;5~&#39;</span> qc-forward-kill-subword     <span style=color:#75715e># [Ctrl+Delete]</span>
</span></span><span style=display:flex><span>bindkey <span style=color:#e6db74>&#39;^[^?&#39;</span>    qc-backward-kill-shellword  <span style=color:#75715e># [Alt+Backspace]</span>
</span></span><span style=display:flex><span>bindkey <span style=color:#e6db74>&#39;^[[3;3~&#39;</span> qc-forward-kill-shellword   <span style=color:#75715e># [Alt+Delete]</span>
</span></span></code></pre></div><p><a href=https://github.com/marlonrichert/zsh-edit>zsh-edit</a>&rsquo;s README explains the effect very well:</p><p>This is how built-in word widgets (<code>{for,back}ward-word</code>, <code>{,backward-}-kill-word</code>) move:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span><span style=color:#75715e># Zsh with default WORDCHARS=&#39;*?_-.[]~=/&amp;;!#$%^(){}&lt;&gt;&#39; moves/deletes way too much:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#              &gt;       &gt;             &gt;             &gt;          &gt;</span>
</span></span><span style=display:flex><span>% ENV_VAR<span style=color:#f92672>=</span>value command --option-flag camelCaseWord ~/dir/*.ext
</span></span><span style=display:flex><span><span style=color:#75715e># &lt;             &lt;       &lt;             &lt;             &lt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Zsh with  WORDCHARS=&#39;&#39; is bit better, but skips punctuation clusters &amp; doesn&#39;t find subWords:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#    &gt;   &gt;     &gt;         &gt;      &gt;    &gt;               &gt;     &gt;</span>
</span></span><span style=display:flex><span>% ENV_VAR<span style=color:#f92672>=</span>value command --option-flag camelCaseWord ~/dir/*.ext
</span></span><span style=display:flex><span><span style=color:#75715e># &lt;   &lt;   &lt;     &lt;         &lt;      &lt;    &lt;               &lt;     &lt;</span>
</span></span></code></pre></div><p>This is how zsh-edit subword widgets move:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span><span style=color:#75715e># Zsh Edit with WORDCHARS=&#39;&#39;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   &gt;   &gt;     &gt;       &gt;  &gt;     &gt;    &gt;     &gt;   &gt;   &gt;  &gt;  &gt;      &gt;</span>
</span></span><span style=display:flex><span>% ENV_VAR<span style=color:#f92672>=</span>value command --option-flag camelCaseWord ~/dir/?*.ext
</span></span><span style=display:flex><span><span style=color:#75715e># &lt;   &lt;   &lt;     &lt;       &lt; &lt;      &lt;    &lt;    &lt;   &lt;    &lt; &lt;      &lt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Zsh Edit with WORDCHARS=&#39;~*?&#39;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#  &gt; &gt;   &gt;  &gt;   &gt;</span>
</span></span><span style=display:flex><span>% cd ~/dir/?*.ext
</span></span><span style=display:flex><span><span style=color:#75715e># &lt;  &lt; &lt;   &lt;  &lt;</span>
</span></span></code></pre></div><p>This function also includes shell-word widgets to let you move with greater strides. They are more intuitive than Zsh&rsquo;s <a href=https://github.com/zsh-users/zsh/blob/master/Functions/Zle/select-word-style><code>select-word-style</code></a> in some edge cases.</p><h3 id=accept-line>Accept line<a hidden class=anchor aria-hidden=true href=#accept-line>#</a></h3><p><strong>Update 2024-03-12</strong>: I find that Roman Perepelitsa has made an excellent plugin called <a href=https://github.com/romkatv/zsh-no-ps2>zsh-no-ps2</a> for this purpose. It&rsquo;s more thoughtful and rigorous than my widget.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span><span style=color:#75715e># [Enter] Insert `\n` when accept-line would result in a parse error or PS2</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Ref: https://github.com/romkatv/zsh4humans/blob/v5/fn/z4h-accept-line</span>
</span></span><span style=display:flex><span>qc-accept-line<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[[</span> <span style=color:#66d9ef>$(</span>functions<span style=color:#f92672>[</span>_qc-test<span style=color:#f92672>]=</span>$BUFFER 2&gt;&amp;1<span style=color:#66d9ef>)</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;&#39;</span> <span style=color:#f92672>]]</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        zle .accept-line
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        LBUFFER<span style=color:#f92672>+=</span><span style=color:#e6db74>$&#39;\n&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>zle -N qc-accept-line
</span></span><span style=display:flex><span>bindkey <span style=color:#e6db74>&#39;^M&#39;</span> qc-accept-line
</span></span></code></pre></div><p>On occasion, we may unintentionally hit a key &ndash; like <code>'</code> &ndash; before hitting enter. And that will result in a secondary prompt (PS2), which is poorly supported, and your first line will be recorded in history anyway.</p><p>In contrast, my widget gives you a newline instead in that scenario, so you can just delete back to correct your command. Moreover, my widget makes writing multi-line commands easier.</p><h3 id=trim-paste>Trim paste<a hidden class=anchor aria-hidden=true href=#trim-paste>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span><span style=color:#75715e># Trim trailing whitespace from pasted text</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Ref: https://unix.stackexchange.com/questions/693118</span>
</span></span><span style=display:flex><span>qc-trim-paste<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    zle .bracketed-paste
</span></span><span style=display:flex><span>    LBUFFER<span style=color:#f92672>=</span><span style=color:#e6db74>${</span>LBUFFER%%[[:space:]]#<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>zle -N bracketed-paste qc-trim-paste
</span></span></code></pre></div><p>Sometimes, we want to copy some command from the browser, say:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span>echo <span style=color:#e6db74>&#39;hello world&#39;</span>
</span></span></code></pre></div><p>We triple-click it to select the whole line and then copy. However, triple-clicking also selects the newline character. This could be annoying when pasting to the terminal. Have a try!</p><p>Thankfully, we have <code>bracketed-paste</code> handling all pasted text. We can hook pasting by overwriting this widget. The same trick is used by <a href=https://github.com/zsh-users/zsh/blob/master/Functions/Zle/bracketed-paste-magic>bracketed-paste-magic</a> and <a href=https://github.com/zsh-users/zsh/blob/master/Functions/Zle/bracketed-paste-url-magic>bracketed-paste-url-magic</a>.</p><h3 id=rationalize-dot>Rationalize dot<a hidden class=anchor aria-hidden=true href=#rationalize-dot>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span><span style=color:#75715e># Change `...` to `../..`</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Ref: https://grml.org/zsh/zsh-lovers.html#_completion</span>
</span></span><span style=display:flex><span>qc-rationalize-dot<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[[</span> $LBUFFER <span style=color:#f92672>==</span> *.. <span style=color:#f92672>]]</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        LBUFFER<span style=color:#f92672>+=</span><span style=color:#e6db74>&#39;/..&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        LBUFFER<span style=color:#f92672>+=</span><span style=color:#e6db74>&#39;.&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>zle -N qc-rationalize-dot
</span></span><span style=display:flex><span>bindkey <span style=color:#e6db74>&#39;.&#39;</span> qc-rationalize-dot
</span></span><span style=display:flex><span>bindkey <span style=color:#e6db74>&#39;^[.&#39;</span> self-insert-unmeta  <span style=color:#75715e># [Alt+.] insert dot</span>
</span></span></code></pre></div><p>It&rsquo;s a better alternative to traditional <code>...</code>/<code>....</code>/<code>.....</code> aliases. It&rsquo;s more readable and supports unlimited levels.</p><h3 id=clear-screen>Clear screen<a hidden class=anchor aria-hidden=true href=#clear-screen>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span><span style=color:#75715e># [Ctrl+L] Clear screen but keep scrollback</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Ref: https://superuser.com/questions/1389834</span>
</span></span><span style=display:flex><span>qc-clear-screen<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    local prompt_height<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>echo -n <span style=color:#e6db74>${</span>(%%)PS1<span style=color:#e6db74>}</span> | wc -l<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>    local lines<span style=color:#f92672>=</span><span style=color:#66d9ef>$((</span>LINES <span style=color:#f92672>-</span> prompt_height<span style=color:#66d9ef>))</span>
</span></span><span style=display:flex><span>    printf <span style=color:#e6db74>&#34;</span>$terminfo<span style=color:#e6db74>[cud1]%.0s&#34;</span> <span style=color:#f92672>{</span>1..$lines<span style=color:#f92672>}</span>  <span style=color:#75715e># cursor down</span>
</span></span><span style=display:flex><span>    printf <span style=color:#e6db74>&#34;</span>$terminfo<span style=color:#e6db74>[cuu1]%.0s&#34;</span> <span style=color:#f92672>{</span>1..$lines<span style=color:#f92672>}</span>  <span style=color:#75715e># cursor up</span>
</span></span><span style=display:flex><span>    zle .reset-prompt
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>zle -N qc-clear-screen
</span></span><span style=display:flex><span>bindkey <span style=color:#e6db74>&#39;^L&#39;</span> qc-clear-screen
</span></span></code></pre></div><p>Zsh has a built-in <code>clear-screen</code> widget bound to <code>[Ctrl+L]</code> by default. But it also erases your terminal emulator&rsquo;s whole history in addition to the screen. My widget can keep the scrollback.</p><p>And it&rsquo;s more flexible. You can customize prompt position by adjusting the number of lines. For example, <code>local lines=$((LINES/2))</code> moves the prompt to the middle.</p><h3 id=fuck>Fuck<a hidden class=anchor aria-hidden=true href=#fuck>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span><span style=color:#75715e># [Esc Esc] Correct previous command</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Ref: https://github.com/ohmyzsh/ohmyzsh/blob/master/plugins/thefuck</span>
</span></span><span style=display:flex><span>qc-fuck<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    local fuck<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>THEFUCK_REQUIRE_CONFIRMATION<span style=color:#f92672>=</span>false thefuck <span style=color:#66d9ef>$(</span>fc -ln -1<span style=color:#66d9ef>)</span> 2&gt;/dev/null<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[[</span> $fuck !<span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span> <span style=color:#f92672>]]</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        compadd -Q $fuck
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        compadd -x <span style=color:#e6db74>&#39;%F{red}-- no fucks given --%f&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>zle -C qc-fuck complete-word qc-fuck
</span></span><span style=display:flex><span>bindkey <span style=color:#e6db74>&#39;\e\e&#39;</span> qc-fuck
</span></span></code></pre></div><p>It&rsquo;s a powerful replacement of oh-my-zsh&rsquo;s <a href=https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/sudo>sudo plugin</a>. It calls <code>thefuck</code> to correct previous command. There are many cases that sudo plugin cannot handle, for example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span>echo <span style=color:#ae81ff>1</span> &gt; /sys/devices/system/cpu/cpufreq/boost
</span></span></code></pre></div><p>You can&rsquo;t simply prefix it with <code>sudo</code> as <code>echo</code> is not a program but a shell built-in command. Now, <a href=https://github.com/nvbn/thefuck>thefuck</a> to the rescue. It can smartly prompt <code>sudo sh -c "echo 1 > /sys/devices/system/cpu/cpufreq/boost"</code>.</p><p>It&rsquo;s better than using <code>fuck</code> as well. Because you can edit the command before executing it.</p><h2 id=more>More<a hidden class=anchor aria-hidden=true href=#more>#</a></h2><p>Here are some key-bindings that aren&rsquo;t up my street but are still useful.</p><h3 id=fzf>fzf<a hidden class=anchor aria-hidden=true href=#fzf>#</a></h3><p><a href=https://github.com/junegunn/fzf>fzf</a> is a fuzzy finder. It can be integrated to many commands to provide a handy selection menu. fzf offers some completions and key-bindings under the <code>shell</code> folder. For Zsh, that includes:</p><ul><li><code>[Ctrl+T]</code> - Paste the selected file path(s) into the command line</li><li><code>[Alt+C]</code> - <code>cd</code> into the selected directory</li><li><code>[Ctrl+R]</code> - Paste the selected command from history into the command line</li></ul><p>I also recommend you to take a look at <a href=https://github.com/Aloxaf/fzf-tab>fzf-tab</a>, a fabulous completion plugin.</p><h3 id=xplr>xplr<a hidden class=anchor aria-hidden=true href=#xplr>#</a></h3><p><a href=https://github.com/sayanarijit/xplr>xplr</a> is a TUI file explorer. Its <a href=https://xplr.dev/en/awesome-hacks>document</a> offers a bunch of hacks. I used to enjoy this key-binding:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span><span style=color:#75715e># [Ctrl+N] Navigate by xplr</span>
</span></span><span style=display:flex><span><span style=color:#75715e># This is not a widget since properly resetting prompt is hard</span>
</span></span><span style=display:flex><span><span style=color:#75715e># See https://github.com/romkatv/powerlevel10k/issues/72</span>
</span></span><span style=display:flex><span>bindkey -s <span style=color:#e6db74>&#39;^N&#39;</span> <span style=color:#e6db74>&#39;^Q cd -- $(xplr --print-pwd-as-result) \n&#39;</span>
</span></span></code></pre></div><p>I&rsquo;ve spent enough time on this blog. There are more awesome projects but I&rsquo;m too lazy to introduce all of them. Some are listed below.</p><ul><li><a href=https://github.com/matschaffer/oh-my-zsh-custom/blob/master/mouse.zsh>mouse.zsh</a></li><li><a href=https://github.com/hchbaw/zce.zsh>zce.zsh</a></li><li><a href=https://github.com/cantino/mcfly>mcfly</a></li><li><a href=https://github.com/atuinsh/atuin>atuin</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.quarticcat.com/tags/zsh/>Zsh</a></li></ul><nav class=paginav><a class=prev href=https://blog.quarticcat.com/posts/no-more-oom/><span class=title>« Prev</span><br><span>No more OOM in C/C++/Rust builds</span>
</a><a class=next href=https://blog.quarticcat.com/posts/optimize-difftastic/><span class=title>Next »</span><br><span>How do I boost difftastic by 4x</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.quarticcat.com/>QuarticCat's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>