<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How to read C++ types | QuarticCat's Blog</title>
<meta name=keywords content="cpp"><meta name=description content="The readability of C++&rsquo;s types is terrible, and most beginner tutorials don&rsquo;t go into detail about how to read them. They at most discuss the difference between top-level const and low-level const. Many of my friends have asked me about this, and I&rsquo;ve talked about it numerous times. So I thought, why not write a blog post on it?
A common misconception Before talking about type reading in detail, I&rsquo;d like to address a common misconception."><meta name=author content="QuarticCat"><link rel=canonical href=https://blog.quarticcat.com/posts/read-cpp-types/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.quarticcat.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.quarticcat.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.quarticcat.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.quarticcat.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.quarticcat.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://blog.quarticcat.com/zh/posts/read-cpp-types/><link rel=alternate hreflang=en href=https://blog.quarticcat.com/posts/read-cpp-types/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "f4a0d5ded0bc48e19ea90f852a11cb57"}'></script><meta property="og:title" content="How to read C++ types"><meta property="og:description" content="The readability of C++&rsquo;s types is terrible, and most beginner tutorials don&rsquo;t go into detail about how to read them. They at most discuss the difference between top-level const and low-level const. Many of my friends have asked me about this, and I&rsquo;ve talked about it numerous times. So I thought, why not write a blog post on it?
A common misconception Before talking about type reading in detail, I&rsquo;d like to address a common misconception."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.quarticcat.com/posts/read-cpp-types/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-02-13T00:00:00+00:00"><meta property="article:modified_time" content="2021-02-13T00:00:00+00:00"><meta property="og:site_name" content="QuarticCat's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="How to read C++ types"><meta name=twitter:description content="The readability of C++&rsquo;s types is terrible, and most beginner tutorials don&rsquo;t go into detail about how to read them. They at most discuss the difference between top-level const and low-level const. Many of my friends have asked me about this, and I&rsquo;ve talked about it numerous times. So I thought, why not write a blog post on it?
A common misconception Before talking about type reading in detail, I&rsquo;d like to address a common misconception."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.quarticcat.com/posts/"},{"@type":"ListItem","position":2,"name":"How to read C++ types","item":"https://blog.quarticcat.com/posts/read-cpp-types/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How to read C++ types","name":"How to read C\u002b\u002b types","description":"The readability of C++\u0026rsquo;s types is terrible, and most beginner tutorials don\u0026rsquo;t go into detail about how to read them. They at most discuss the difference between top-level const and low-level const. Many of my friends have asked me about this, and I\u0026rsquo;ve talked about it numerous times. So I thought, why not write a blog post on it?\nA common misconception Before talking about type reading in detail, I\u0026rsquo;d like to address a common misconception.","keywords":["cpp"],"articleBody":"The readability of C++’s types is terrible, and most beginner tutorials don’t go into detail about how to read them. They at most discuss the difference between top-level const and low-level const. Many of my friends have asked me about this, and I’ve talked about it numerous times. So I thought, why not write a blog post on it?\nA common misconception Before talking about type reading in detail, I’d like to address a common misconception.\nQ: What’s the type of a in int a[5]?\nA: int[5], and will decay to int* when appropriate.\nQ: What’s the type of a in int a[5][6]?\nA: int[5][6], and will decay to int(*)[6], the pointer to int[6], when appropriate.\nBecause of the existence of decay rules, many C++ beginners consider array types and pointer types the same. But they are different.\nSimilarly, function types will also decay to pointer types. For instance, int(int, int) will decay to int(*)(int, int).\nSolving equations You might have seen some people saying that reading C++’s types is just solving equations. Let me explain this statement.\nLeaving aside CVR (const, volatile, reference), the most basic declarations in C++ can be divided into two parts: the type names written on the leftmost are the type specifiers, and the rest are the declarators. These parts are inherited from C. They are the nastiest component of C++ types. These two names are not intuitive, I like to refer them as “return types” and “expressions”, as will be explained later. Let’s first start with a few examples.\nDeclaration Type Specifier Declarator int a int a int* a int *a int a[5] int a[5] int* a[5] int *a[5] int (*a)[5] int (*a)[5] After separating these two parts, it is now easy to understand how the types of as above are determined: using a as the form of the declarator, then the type of the return value is just the type specifier. The so-called equation solving is just such a process:\nFrom int *a[5] we have that the type of *a[5] is int. That is, dereferencing a[5] returns a int, which means the type of a[5] is int*. That is, indexing a returns a int*, which means the type of a is an array of 5 int*。 Another example:\nFrom int (*a)[5] we have that the type of (*a)[5] is int. That is, indexing (*a) returns a int, which means the type of (*a) is int[5]. That is, dereferencing a returns a int[5], which means the type of a is a pointer to int[5]. You can see that the operator precedence here is exactly the same as in expressions, and the form is basically the same as well.\nOne more example:\nFrom int (*a)(int, int) we have that the type of (*a)(int, int) is int. That is, calling (*a) in the form of (int, int) returns a int, which means the type of (*a) is a function that has two int parameters and returns a int, i.e., int(int, int). That is, dereferencing a returns int(int, int), which means the type of a is a pointer to int(int, int). A more complex example:\nFrom int (*(Foo::*a[5])(int, int))(int) we have that the type of (*(Foo::*a[5])(int, int))(int) is int. So the type of (*(Foo::*a[5])(int, int)) is int(int). So the type of (Foo::*a[5])(int, int) is a pointer to int(int), i.e., int(*)(int). So the type of (Foo::*a[5]) is a function that has two int parameters and returns a int(*)(int). So the type of a[5] is a member pointer to that function. So the type of a is an array of 5 that member pointers. In short, you can consider the declarator as an expression, and the type of this expression is the type specifier. Using this rule, you can infer the type backward.\nOf course, writing complex types in the way shown above is not recommended. That declaration is only for illustration. In real world code, it might be written as the following:\nstruct Foo { auto bar(int, int) -\u003e int(*)(int); }; decltype(\u0026Foo::bar) a[5]; Before C++11, you can use typedef to decompose that declaration to improve readability.\nstruct Foo { typedef int (*bar_t)(int); bar_t bar(int, int); }; typedef Foo::bar_t (Foo::*foo_bar_t)(int, int); foo_bar_t a[5]; Such type aliases are very common in C.\nBut if the type comes from demangling, it will be the hideous one-line looking.\nMulti-variable declarations After you can distinguish between type specifiers and declarators, it’s easy to understand the rules of C++ multi-variable declarations. In multi-variable declarations, the comma-separated declarators (the expressions) share one type specifier (the return type). For example:\nint *a, b; The type of a is int* while the type of b is int, since * is a part of the declarator. If you wish to define two pointers, you should write int *a, *b instead.\nMore complex examples follow the same rules. Since I can’t think of any point in doing this, I won’t give more examples.\nconst and volatile const and volatile take the same position in declarations, and they can be used together. Here for simplicity, only const will be used in the following examples. All const below can be (syntactically) legally replaced by volatile, const volatile, and volatile const. The latter two are semantically equal.\nconst usually has a clear meaning, as in const int a and int (*a)(const std::string\u0026). Confusions of const often involve pointers. For pointers, const needs to express two meanings:\nThe pointer itself is const, i.e., it cannot point to other values, like char *const a. The pointee it points to is const, i.e., you cannot modify the pointee through the pointer, like const char* a. When there are nested pointers, we also have to consider the const property of those inner pointers, so the types become complicated. With the previous knowledge, we can divide consts into consts on type specifiers and consts on declarators. Look at the following type:\nconst int * const * * const a; The leftmost const is on the type specifier, and the rest consts are on the declarators.\nconsts on type specifiers are required to be placed aside type specifiers. Both const T and T const are legal and semantically equal. Thus, the above example can be written as:\nint const * const * * const a; They both mean that\nThe type of * const * * const a is const int (cannot modify ***a). To distinguish that which const specifies which part, you only need to take care that when you encounter a const during the equation solving.\nThe type of * * const a is a const pointer to const int (cannot modify **a). The type of * const a is a non-const pointer to the previous pointer (can modify *a). The type of a is a const pointer to the previous pointer (cannot modify a). The famous C++ book C++ Primer divides consts into top-level consts and low-level consts. The term top-level const refers to the const that specifies the pointer itself, i.e., the innermost one; the term low-level const refers to the rest.\n\u0026 and \u0026\u0026 References in C++ is very special. Since C++ standard specifies that references don’t necessarily occupy memory space, you can’t write arrays of references (int\u0026 a[5]) and pointers to references (int\u0026* a) and many other reference related types. I think it’s a huge design failure. It adds a lot of obstacles out of nowhere.\nAnyway, except for function types (and types that contains function types) where \u0026 and \u0026\u0026 can appear in the argument type and return value type, in other cases \u0026 and \u0026\u0026 can only appear at the top level of the type. The meaning of “top-level” here is the same as top-level const in the previous section.\nDirectly nesting \u0026 and \u0026\u0026, like int\u0026 \u0026\u0026 a, is not allowed. But indirectly nesting them is allowed. For example:\nusing ref1 = int\u0026\u0026; using ref2 = ref1\u0026\u0026; using ref3 = ref2\u0026; In this case, reference collapsing will occur. The rule of reference collapsing is simple: if there are all \u0026\u0026, then final type will be \u0026\u0026; if there is one \u0026, then the final type will be \u0026. So the ref2 above is actually int\u0026\u0026, while the ref3 is int\u0026.\nAnother usage of \u0026\u0026 is in templates. If T is a template parameter, then T\u0026\u0026 (without const and volatile) is a universal reference. It has the following rules:\nIf the argument passed to T\u0026\u0026 has type Foo\u0026, then T is inferred to Foo\u0026, then T\u0026\u0026 becomes Foo\u0026 after reference collapsing. If the argument passed to T\u0026\u0026 has type Foo\u0026\u0026, then T is inferred to Foo, then T\u0026\u0026 becomes Foo\u0026\u0026 after reference collapsing. Note that it’s important that T is inferred to what type, because you might want to use T somewhere inside the template.\nMember functions In C++, sometimes we can see code like this:\nstruct Foo { int a(int, int) const; }; struct Bar { int a(int, int) \u0026\u0026; }; This is easy to understand. Each non-static member function in C++ has an implicitly defined this pointer that points to the instance. The const and \u0026\u0026 written after it are used to specify instances.\nOn some other languages like Rust and Python, the passed instance is written explicitly as the first parameter, whereas in C++ it is implicit (before C++23). So you have to add type specifiers elsewhere. The following examples loosely reveal how those type specifiers work.\nstruct Foo { // void a(const Foo\u0026 this_, int) { // const Foo* this = \u0026this_; // } void a(int) const\u0026; // void a(Foo\u0026\u0026 this_, int) { // Foo* this = \u0026this_; // } void a(int) \u0026\u0026; // void a(Foo\u0026 this_, int) { // Foo* this = \u0026this_; // } void a(int) \u0026; // foo.a(1) -\u003e Foo::a(foo, 1) }; struct Bar { // void a(const Bar\u0026 this_, int) { // const Bar* this = \u0026this_; // } // // or just: // // void a(const Bar* this, int); void a(int) const; // void a(Bar\u0026 this_, int) { // Bar* this = \u0026this_; // } // // or just: // // void a(Bar* this, int); void a(int); // bar.a(1) -\u003e Bar::a(bar, 1) // // or: // // bar.a(1) -\u003e Bar::a(\u0026bar, 1) }; Member functions with references cannot be overloaded with member functions without references. You either choose the set demonstrated by Foo or the set demonstrated by Bar. Some other possible overloads, such as those with volatile, are omitted.\ntypedef and using I have shown examples of typedef and using in previous sections. The syntax of typedef is exactly the same as defining a variable. The only one difference in syntax between typedef and using is that using put the type name in the left. In the following example, both foo_t and bar_t have the same type of func_ptr.\nint (*func_ptr)(int); typedef int (*foo_t)(int); using bar_t = int(*)(int); Compared to typedef, one advantage of using is that it can use templates. E.g.,\ntemplate\u003ctypename T\u003e using foo_t = std::vector\u003cT\u003e; foo_t\u003cint\u003e foo; Before C++11, you can implement this through wrapping typedef by a struct or a class. E.g.,\ntemplate\u003ctypename T\u003e struct Bar { typedef std::vector\u003cT\u003e type; }; Bar\u003cint\u003e::type bar; This post only discusses types, so other semantics of using will be skipped.\nMore The components of the C++ declaration statement are quite complex, not just the type specifiers and declarators. But the rest of them are much more human-friendly, and many of them are not part of types. For those who interested in learning more, please read cppreference.\nTypes could have been clear and easy to read, it’s just that C and C++’s design is terrible. Now that you’ve read this article, congratulations on solving a problem that doesn’t even exist in other languages.\n","wordCount":"1941","inLanguage":"en","datePublished":"2021-02-13T00:00:00Z","dateModified":"2021-02-13T00:00:00Z","author":{"@type":"Person","name":"QuarticCat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.quarticcat.com/posts/read-cpp-types/"},"publisher":{"@type":"Organization","name":"QuarticCat's Blog","logo":{"@type":"ImageObject","url":"https://blog.quarticcat.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.quarticcat.com/ accesskey=h title="Home (Alt + H)"><img src=https://blog.quarticcat.com/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.quarticcat.com/zh/ title=中文 aria-label=中文>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://blog.quarticcat.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://blog.quarticcat.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.quarticcat.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.quarticcat.com/blogroll/ title=Blogroll><span>Blogroll</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">How to read C++ types</h1><div class=post-meta><span title='2021-02-13 00:00:00 +0000 UTC'>February 13, 2021</span>&nbsp;·&nbsp;QuarticCat&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://blog.quarticcat.com/zh/posts/read-cpp-types/>Zh</a></li></ul></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#a-common-misconception>A common misconception</a></li><li><a href=#solving-equations>Solving equations</a></li><li><a href=#multi-variable-declarations>Multi-variable declarations</a></li><li><a href=#const-and-volatile><code>const</code> and <code>volatile</code></a></li><li><a href=#-and-><code>&</code> and <code>&&</code></a></li><li><a href=#member-functions>Member functions</a></li><li><a href=#typedef-and-using><code>typedef</code> and <code>using</code></a></li><li><a href=#more>More</a></li></ul></nav></div></details></div><div class=post-content><p>The readability of C++&rsquo;s types is terrible, and most beginner tutorials don&rsquo;t go into detail about how to read them. They at most discuss the difference between <em>top-level const</em> and <em>low-level const</em>. Many of my friends have asked me about this, and I&rsquo;ve talked about it numerous times. So I thought, why not write a blog post on it?</p><h2 id=a-common-misconception>A common misconception<a hidden class=anchor aria-hidden=true href=#a-common-misconception>#</a></h2><p>Before talking about type reading in detail, I&rsquo;d like to address a common misconception.</p><p>Q: What&rsquo;s the type of <code>a</code> in <code>int a[5]</code>?</p><p>A: <code>int[5]</code>, and will <em>decay</em> to <code>int*</code> when appropriate.</p><p>Q: What&rsquo;s the type of <code>a</code> in <code>int a[5][6]</code>?</p><p>A: <code>int[5][6]</code>, and will <em>decay</em> to <code>int(*)[6]</code>, the pointer to <code>int[6]</code>, when appropriate.</p><p>Because of the existence of <em>decay</em> rules, many C++ beginners consider array types and pointer types the same. But they are different.</p><p>Similarly, function types will also <em>decay</em> to pointer types. For instance, <code>int(int, int)</code> will <em>decay</em> to <code>int(*)(int, int)</code>.</p><h2 id=solving-equations>Solving equations<a hidden class=anchor aria-hidden=true href=#solving-equations>#</a></h2><p>You might have seen some people saying that reading C++&rsquo;s types is just solving equations. Let me explain this statement.</p><p>Leaving aside CVR (const, volatile, reference), the most basic declarations in C++ can be divided into two parts: the <strong>type names</strong> written on the leftmost are the <em>type specifiers</em>, and the rest are the <em>declarators</em>. These parts are inherited from C. They are the nastiest component of C++ types. These two names are not intuitive, I like to refer them as &ldquo;return types&rdquo; and &ldquo;expressions&rdquo;, as will be explained later. Let&rsquo;s first start with a few examples.</p><table><thead><tr><th style=text-align:center>Declaration</th><th style=text-align:center>Type Specifier</th><th style=text-align:center>Declarator</th></tr></thead><tbody><tr><td style=text-align:center><code>int a</code></td><td style=text-align:center><code>int</code></td><td style=text-align:center><code>a</code></td></tr><tr><td style=text-align:center><code>int* a</code></td><td style=text-align:center><code>int</code></td><td style=text-align:center><code>*a</code></td></tr><tr><td style=text-align:center><code>int a[5]</code></td><td style=text-align:center><code>int</code></td><td style=text-align:center><code>a[5]</code></td></tr><tr><td style=text-align:center><code>int* a[5]</code></td><td style=text-align:center><code>int</code></td><td style=text-align:center><code>*a[5]</code></td></tr><tr><td style=text-align:center><code>int (*a)[5]</code></td><td style=text-align:center><code>int</code></td><td style=text-align:center><code>(*a)[5]</code></td></tr></tbody></table><p>After separating these two parts, it is now easy to understand how the types of <code>a</code>s above are determined: using <code>a</code> as the form of the <em>declarator</em>, then the type of the return value is just the <em>type specifier</em>. The so-called equation solving is just such a process:</p><ol><li>From <code>int *a[5]</code> we have that the type of <code>*a[5]</code> is <code>int</code>.</li><li>That is, dereferencing <code>a[5]</code> returns a <code>int</code>, which means the type of <code>a[5]</code> is <code>int*</code>.</li><li>That is, indexing <code>a</code> returns a <code>int*</code>, which means the type of <code>a</code> is an array of 5 <code>int*</code>。</li></ol><p>Another example:</p><ol><li>From <code>int (*a)[5]</code> we have that the type of <code>(*a)[5]</code> is <code>int</code>.</li><li>That is, indexing <code>(*a)</code> returns a <code>int</code>, which means the type of <code>(*a)</code> is <code>int[5]</code>.</li><li>That is, dereferencing <code>a</code> returns a <code>int[5]</code>, which means the type of <code>a</code> is a pointer to <code>int[5]</code>.</li></ol><p>You can see that the operator precedence here is exactly the same as in expressions, and the form is basically the same as well.</p><p>One more example:</p><ol><li>From <code>int (*a)(int, int)</code> we have that the type of <code>(*a)(int, int)</code> is <code>int</code>.</li><li>That is, calling <code>(*a)</code> in the form of <code>(int, int)</code> returns a <code>int</code>, which means the type of <code>(*a)</code> is a function that has two <code>int</code> parameters and returns a <code>int</code>, i.e., <code>int(int, int)</code>.</li><li>That is, dereferencing <code>a</code> returns <code>int(int, int)</code>, which means the type of <code>a</code> is a pointer to <code>int(int, int)</code>.</li></ol><p>A more complex example:</p><ol><li>From <code>int (*(Foo::*a[5])(int, int))(int)</code> we have that the type of <code>(*(Foo::*a[5])(int, int))(int)</code> is <code>int</code>.</li><li>So the type of <code>(*(Foo::*a[5])(int, int))</code> is <code>int(int)</code>.</li><li>So the type of <code>(Foo::*a[5])(int, int)</code> is a pointer to <code>int(int)</code>, i.e., <code>int(*)(int)</code>.</li><li>So the type of <code>(Foo::*a[5])</code> is a function that has two <code>int</code> parameters and returns a <code>int(*)(int)</code>.</li><li>So the type of <code>a[5]</code> is a member pointer to that function.</li><li>So the type of <code>a</code> is an array of 5 that member pointers.</li></ol><p><strong>In short, you can consider the <em>declarator</em> as an expression, and the type of this expression is the <em>type specifier</em>.</strong> Using this rule, you can infer the type backward.</p><p>Of course, writing complex types in the way shown above is not recommended. That declaration is only for illustration. In real world code, it might be written as the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Foo</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> <span style=color:#a6e22e>bar</span>(<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>int</span>(<span style=color:#f92672>*</span>)(<span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>decltype</span>(<span style=color:#f92672>&amp;</span>Foo<span style=color:#f92672>::</span>bar) a[<span style=color:#ae81ff>5</span>];
</span></span></code></pre></div><p>Before C++11, you can use <code>typedef</code> to decompose that declaration to improve readability.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Foo</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>int</span> (<span style=color:#f92672>*</span>bar_t)(<span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span>    bar_t <span style=color:#a6e22e>bar</span>(<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> Foo<span style=color:#f92672>::</span>bar_t (Foo<span style=color:#f92672>::*</span>foo_bar_t)(<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span>foo_bar_t a[<span style=color:#ae81ff>5</span>];
</span></span></code></pre></div><p>Such type aliases are very common in C.</p><p>But if the type comes from demangling, it will be the hideous one-line looking.</p><h2 id=multi-variable-declarations>Multi-variable declarations<a hidden class=anchor aria-hidden=true href=#multi-variable-declarations>#</a></h2><p>After you can distinguish between <em>type specifiers</em> and <em>declarators</em>, it&rsquo;s easy to understand the rules of C++ multi-variable declarations. In multi-variable declarations, the comma-separated <em>declarators</em> (the expressions) share one <em>type specifier</em> (the return type). For example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>a, b;
</span></span></code></pre></div><p>The type of <code>a</code> is <code>int*</code> while the type of <code>b</code> is <code>int</code>, since <code>*</code> is a part of the <em>declarator</em>. If you wish to define two pointers, you should write <code>int *a, *b</code> instead.</p><p>More complex examples follow the same rules. Since I can&rsquo;t think of any point in doing this, I won&rsquo;t give more examples.</p><h2 id=const-and-volatile><code>const</code> and <code>volatile</code><a hidden class=anchor aria-hidden=true href=#const-and-volatile>#</a></h2><p><code>const</code> and <code>volatile</code> take the same position in declarations, and they can be used together. Here for simplicity, only <code>const</code> will be used in the following examples. All <code>const</code> below can be (syntactically) legally replaced by <code>volatile</code>, <code>const volatile</code>, and <code>volatile const</code>. The latter two are semantically equal.</p><p><code>const</code> usually has a clear meaning, as in <code>const int a</code> and <code>int (*a)(const std::string&)</code>. Confusions of <code>const</code> often involve pointers. For pointers, <code>const</code> needs to express two meanings:</p><ol><li>The pointer itself is <code>const</code>, i.e., it cannot point to other values, like <code>char *const a</code>.</li><li>The pointee it points to is <code>const</code>, i.e., you cannot modify the pointee through the pointer, like <code>const char* a</code>.</li></ol><p>When there are nested pointers, we also have to consider the <code>const</code> property of those inner pointers, so the types become complicated. With the previous knowledge, we can divide <code>const</code>s into <code>const</code>s on <em>type specifiers</em> and <code>const</code>s on <em>declarators</em>. Look at the following type:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>const</span> a;
</span></span></code></pre></div><p>The leftmost <code>const</code> is on the <em>type specifier</em>, and the rest <code>const</code>s are on the <em>declarators</em>.</p><p><code>const</code>s on <em>type specifiers</em> are required to be placed aside <em>type specifiers</em>. Both <code>const T</code> and <code>T const</code> are legal and semantically equal. Thus, the above example can be written as:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>const</span> a;
</span></span></code></pre></div><p>They both mean that</p><ol><li>The type of <code>* const * * const a</code> is <code>const int</code> (cannot modify <code>***a</code>).</li></ol><p>To distinguish that which <code>const</code> specifies which part, you only need to take care that when you encounter a <code>const</code> during the equation solving.</p><ol start=2><li>The type of <code>* * const a</code> is a const pointer to <code>const int</code> (cannot modify <code>**a</code>).</li><li>The type of <code>* const a</code> is a non-const pointer to the previous pointer (can modify <code>*a</code>).</li><li>The type of <code>a</code> is a const pointer to the previous pointer (cannot modify <code>a</code>).</li></ol><p>The famous C++ book <em>C++ Primer</em> divides <code>const</code>s into <em>top-level consts</em> and <em>low-level consts</em>. The term <em>top-level const</em> refers to the <code>const</code> that specifies the pointer itself, i.e., the innermost one; the term <em>low-level const</em> refers to the rest.</p><h2 id=-and-><code>&</code> and <code>&&</code><a hidden class=anchor aria-hidden=true href=#-and->#</a></h2><p>References in C++ is very special. Since C++ standard specifies that references don&rsquo;t necessarily occupy memory space, you can&rsquo;t write arrays of references (<code>int& a[5]</code>) and pointers to references (<code>int&* a</code>) and many other reference related types. I think it&rsquo;s a huge design failure. It adds a lot of obstacles out of nowhere.</p><p>Anyway, except for function types (and types that contains function types) where <code>&</code> and <code>&&</code> can appear in the argument type and return value type, in other cases <code>&</code> and <code>&&</code> can only appear at the top level of the type. The meaning of &ldquo;top-level&rdquo; here is the same as <em>top-level const</em> in the previous section.</p><p>Directly nesting <code>&</code> and <code>&&</code>, like <code>int& && a</code>, is not allowed. But indirectly nesting them is allowed. For example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>using</span> ref1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;&amp;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> ref2 <span style=color:#f92672>=</span> ref1<span style=color:#f92672>&amp;&amp;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> ref3 <span style=color:#f92672>=</span> ref2<span style=color:#f92672>&amp;</span>;
</span></span></code></pre></div><p>In this case, <em>reference collapsing</em> will occur. The rule of <em>reference collapsing</em> is simple: if there are all <code>&&</code>, then final type will be <code>&&</code>; if there is one <code>&</code>, then the final type will be <code>&</code>. So the <code>ref2</code> above is actually <code>int&&</code>, while the <code>ref3</code> is <code>int&</code>.</p><p>Another usage of <code>&&</code> is in templates. If <code>T</code> is a template parameter, then <code>T&&</code> (without <code>const</code> and <code>volatile</code>) is a <em>universal reference</em>. It has the following rules:</p><ol><li>If the argument passed to <code>T&&</code> has type <code>Foo&</code>, then <code>T</code> is inferred to <code>Foo&</code>, then <code>T&&</code> becomes <code>Foo&</code> after <em>reference collapsing</em>.</li><li>If the argument passed to <code>T&&</code> has type <code>Foo&&</code>, then <code>T</code> is inferred to <code>Foo</code>, then <code>T&&</code> becomes <code>Foo&&</code> after <em>reference collapsing</em>.</li></ol><p>Note that it&rsquo;s important that <code>T</code> is inferred to what type, because you might want to use <code>T</code> somewhere inside the template.</p><h2 id=member-functions>Member functions<a hidden class=anchor aria-hidden=true href=#member-functions>#</a></h2><p>In C++, sometimes we can see code like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Foo</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>a</span>(<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Bar</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>a</span>(<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>) <span style=color:#f92672>&amp;&amp;</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>This is easy to understand. Each non-static member function in C++ has an implicitly defined <code>this</code> pointer that points to the instance. The <code>const</code> and <code>&&</code> written after it are used to specify instances.</p><p>On some other languages like Rust and Python, the passed instance is written explicitly as the first parameter, whereas in C++ it is implicit (before C++23). So you have to add type specifiers elsewhere. The following examples loosely reveal how those type specifiers work.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Foo</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// void a(const Foo&amp; this_, int) {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//     const Foo* this = &amp;this_;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>a</span>(<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>const</span><span style=color:#f92672>&amp;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// void a(Foo&amp;&amp; this_, int) {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//     Foo* this = &amp;this_;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>a</span>(<span style=color:#66d9ef>int</span>) <span style=color:#f92672>&amp;&amp;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// void a(Foo&amp; this_, int) {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//     Foo* this = &amp;this_;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>a</span>(<span style=color:#66d9ef>int</span>) <span style=color:#f92672>&amp;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// foo.a(1) -&gt; Foo::a(foo, 1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Bar</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// void a(const Bar&amp; this_, int) {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//     const Bar* this = &amp;this_;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// or just:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// void a(const Bar* this, int);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>a</span>(<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// void a(Bar&amp; this_, int) {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//     Bar* this = &amp;this_;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// or just:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// void a(Bar* this, int);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>a</span>(<span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// bar.a(1) -&gt; Bar::a(bar, 1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// or:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// bar.a(1) -&gt; Bar::a(&amp;bar, 1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><p>Member functions with references cannot be overloaded with member functions without references. You either choose the set demonstrated by <code>Foo</code> or the set demonstrated by <code>Bar</code>. Some other possible overloads, such as those with <code>volatile</code>, are omitted.</p><h2 id=typedef-and-using><code>typedef</code> and <code>using</code><a hidden class=anchor aria-hidden=true href=#typedef-and-using>#</a></h2><p>I have shown examples of <code>typedef</code> and <code>using</code> in previous sections. The syntax of <code>typedef</code> is exactly the same as defining a variable. The only one difference in syntax between <code>typedef</code> and <code>using</code> is that <code>using</code> put the type name in the left. In the following example, both <code>foo_t</code> and <code>bar_t</code> have the same type of <code>func_ptr</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> (<span style=color:#f92672>*</span>func_ptr)(<span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>int</span> (<span style=color:#f92672>*</span>foo_t)(<span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> bar_t <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span>(<span style=color:#f92672>*</span>)(<span style=color:#66d9ef>int</span>);
</span></span></code></pre></div><p>Compared to <code>typedef</code>, one advantage of <code>using</code> is that it can use templates. E.g.,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> foo_t <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>foo_t<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> foo;
</span></span></code></pre></div><p>Before C++11, you can implement this through wrapping <code>typedef</code> by a <code>struct</code> or a <code>class</code>. E.g.,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Bar</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>typedef</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> type;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Bar<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;::</span>type bar;
</span></span></code></pre></div><p>This post only discusses types, so other semantics of <code>using</code> will be skipped.</p><h2 id=more>More<a hidden class=anchor aria-hidden=true href=#more>#</a></h2><p>The components of the C++ declaration statement are quite complex, not just the <em>type specifiers</em> and <em>declarators</em>. But the rest of them are much more human-friendly, and many of them are not part of types. For those who interested in learning more, please read <a href=https://en.cppreference.com/w/cpp/language/declarations>cppreference</a>.</p><p>Types could have been clear and easy to read, it&rsquo;s just that C and C++&rsquo;s design is terrible. Now that you&rsquo;ve read this article, congratulations on solving a problem that doesn&rsquo;t even exist in other languages.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.quarticcat.com/tags/cpp/>Cpp</a></li></ul><nav class=paginav><a class=prev href=https://blog.quarticcat.com/posts/one-more-nasty-design-of-cpp-name-lookup/><span class=title>« Prev</span><br><span>One more nasty design of C++'s name lookup</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.quarticcat.com/>QuarticCat's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>