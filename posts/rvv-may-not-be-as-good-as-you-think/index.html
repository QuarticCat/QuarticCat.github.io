<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>RVV may not be as good as you think | QuarticCat's Blog</title>
<meta name=keywords content="risc-v,simd,vector"><meta name=description content="As an emerging ISA, RISC-V learns a lot from its predecessors&rsquo; mistakes and brings some very appealing designs. In my circles, RISC-V is frequently associated with the words &ldquo;modern&rdquo; and &ldquo;elegant&rdquo;. Its vector extension (RVV) is often given equivalent praise, even though nearly no one has used a real-world RVV machine (including me) or even programmed in RVV. After experimenting with RVV for a while, I feel that it is not as good as many people claimed."><meta name=author content="QuarticCat"><link rel=canonical href=https://blog.quarticcat.com/posts/rvv-may-not-be-as-good-as-you-think/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.quarticcat.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.quarticcat.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.quarticcat.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.quarticcat.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.quarticcat.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.quarticcat.com/posts/rvv-may-not-be-as-good-as-you-think/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "f4a0d5ded0bc48e19ea90f852a11cb57"}'></script><meta property="og:title" content="RVV may not be as good as you think"><meta property="og:description" content="As an emerging ISA, RISC-V learns a lot from its predecessors&rsquo; mistakes and brings some very appealing designs. In my circles, RISC-V is frequently associated with the words &ldquo;modern&rdquo; and &ldquo;elegant&rdquo;. Its vector extension (RVV) is often given equivalent praise, even though nearly no one has used a real-world RVV machine (including me) or even programmed in RVV. After experimenting with RVV for a while, I feel that it is not as good as many people claimed."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.quarticcat.com/posts/rvv-may-not-be-as-good-as-you-think/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-27T00:00:00+00:00"><meta property="article:modified_time" content="2022-02-27T00:00:00+00:00"><meta property="og:site_name" content="QuarticCat's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="RVV may not be as good as you think"><meta name=twitter:description content="As an emerging ISA, RISC-V learns a lot from its predecessors&rsquo; mistakes and brings some very appealing designs. In my circles, RISC-V is frequently associated with the words &ldquo;modern&rdquo; and &ldquo;elegant&rdquo;. Its vector extension (RVV) is often given equivalent praise, even though nearly no one has used a real-world RVV machine (including me) or even programmed in RVV. After experimenting with RVV for a while, I feel that it is not as good as many people claimed."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.quarticcat.com/posts/"},{"@type":"ListItem","position":2,"name":"RVV may not be as good as you think","item":"https://blog.quarticcat.com/posts/rvv-may-not-be-as-good-as-you-think/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"RVV may not be as good as you think","name":"RVV may not be as good as you think","description":"As an emerging ISA, RISC-V learns a lot from its predecessors\u0026rsquo; mistakes and brings some very appealing designs. In my circles, RISC-V is frequently associated with the words \u0026ldquo;modern\u0026rdquo; and \u0026ldquo;elegant\u0026rdquo;. Its vector extension (RVV) is often given equivalent praise, even though nearly no one has used a real-world RVV machine (including me) or even programmed in RVV. After experimenting with RVV for a while, I feel that it is not as good as many people claimed.","keywords":["risc-v","simd","vector"],"articleBody":"As an emerging ISA, RISC-V learns a lot from its predecessors’ mistakes and brings some very appealing designs. In my circles, RISC-V is frequently associated with the words “modern” and “elegant”. Its vector extension (RVV) is often given equivalent praise, even though nearly no one has used a real-world RVV machine (including me) or even programmed in RVV. After experimenting with RVV for a while, I feel that it is not as good as many people claimed.\nHow is RVV designed In contrast to SIMD architectures, RVV has variable-length vector registers. That means different chips (hardware threads, or harts, to be precise) can have different vector register lengths while sharing the same instruction set. To accomplish this, the software must get and set the length parameter with some instructions at runtime. RVV operations distinguish only between vector-vector and vector-scalar, signed and unsigned, but not element lengths. As a result, the element length is a dynamic parameter as well. Furthermore, RVV enables us to use only a portion of a vector register or to combine multiple vector registers, which necessitates the usage of a dynamic parameter. The type of a vector register is mainly governed by the factors listed below.\nVLEN: a constant, represents the length of a vector register on this chip vl: a Control and Status Register, or CSR, controls the number of elements used in operations, making it easier to handle the tail elements of an array vtype: a CSR, includes vill: represents whether the vtype configuration is ill-formed or not vma / vta: controls the operation behavior of those masked-off elements and tail elements vsew: controls the length of a single element, represented by SEW = 8 | 16 | 32 | 64 vlmul: controls how many registers are used in an operation, represented by LMUL = 1/8 | 1/4 | 1/2 | 1 | 2 | 4 | 8 We use vset{i}vl{i} instructions to set both vl and vtype.\nI need to elaborate on the parameter LMUL. When LMUL = 1/2, for example, we only use half of the registers. When LMUL = 8, we combine 8 contiguous registers into one, resulting in 32 / 8 = 4 accessible registers. Since there are only 5 bits for a register index in all RVV instructions, we don’t receive more registers when LMUL \u003c 1.\nThere are a few other parameters. However, they will not be discussed in this blog, so I will not list them.\nMore details can be found in the RVV Spec. I’ll end my introduction here.\nAnnoyances of RVV C intrinsics In RVV C intrinsics, vl, vma, vta are specified at function invocations, whereas vsew, vlmul are hard-coded into types. Compilers are responsible to insert vset{i}vl{i} instructions for you. We now have the following horrible table (source: RVV Intrinsic RFC).\nData Types Encode SEW and LMUL into data types. We enforce the constraint LMUL ≥ SEW/ELEN in the implementation. There are the following data types for ELEN = 64.\nTypes LMUL = 1 LMUL = 2 LMUL = 4 LMUL = 8 LMUL = 1/2 LMUL = 1/4 LMUL = 1/8 int64_t vint64m1_t vint64m2_t vint64m4_t vint64m8_t N/A N/A N/A uint64_t vuint64m1_t vuint64m2_t vuint64m4_t vuint64m8_t N/A N/A N/A int32_t vint32m1_t vint32m2_t vint32m4_t vint32m8_t vint32mf2_t N/A N/A uint32_t vuint32m1_t vuint32m2_t vuint32m4_t vuint32m8_t vuint32mf2_t N/A N/A int16_t vint16m1_t vint16m2_t vint16m4_t vint16m8_t vint16mf2_t vint16mf4_t N/A uint16_t vuint16m1_t vuint16m2_t vuint16m4_t vuint16m8_t vuint16mf2_t vuint16mf4_t N/A int8_t vint8m1_t vint8m2_t vint8m4_t vint8m8_t vint8mf2_t vint8mf4_t vint8mf8_t uint8_t vuint8m1_t vuint8m2_t vuint8m4_t vuint8m8_t vuint8mf2_t vuint8mf4_t vuint8mf8_t vfloat64 vfloat64m1_t vfloat64m2_t vfloat64m4_t vfloat64m8_t N/A N/A N/A vfloat32 vfloat32m1_t vfloat32m2_t vfloat32m4_t vfloat32m8_t vfloat32mf2_t N/A N/A vfloat16 vfloat16m1_t vfloat16m2_t vfloat16m4_t vfloat16m8_t vfloat16mf2_t vfloat16mf4_t N/A There are the following data types for ELEN = 32.\nTypes LMUL = 1 LMUL = 2 LMUL = 4 LMUL = 8 LMUL = 1/2 LMUL = 1/4 LMUL = 1/8 int32_t vint32m1_t vint32m2_t vint32m4_t vint32m8_t N/A N/A N/A uint32_t vuint32m1_t vuint32m2_t vuint32m4_t vuint32m8_t N/A N/A N/A int16_t vint16m1_t vint16m2_t vint16m4_t vint16m8_t vint16mf2_t N/A N/A uint16_t vuint16m1_t vuint16m2_t vuint16m4_t vuint16m8_t vuint16mf2_t N/A N/A int8_t vint8m1_t vint8m2_t vint8m4_t vint8m8_t vint8mf2_t vint8mf4_t N/A uint8_t vuint8m1_t vuint8m2_t vuint8m4_t vuint8m8_t vuint8mf2_t vuint8mf4_t N/A vfloat32 vfloat32m1_t vfloat32m2_t vfloat32m4_t vfloat32m8_t N/A N/A N/A vfloat16 vfloat16m1_t vfloat16m2_t vfloat16m4_t vfloat16m8_t vfloat16mf2_t N/A N/A Mask Types Encode the ratio of SEW/LMUL into the mask types. There are the following mask types.\nn = SEW/LMUL\nTypes n = 1 n = 2 n = 4 n = 8 n = 16 n = 32 n = 64 bool vbool1_t vbool2_t vbool4_t vbool8_t vbool16_t vbool32_t vbool64_t There are a lot of N/A here, which makes it a little difficult to generate code with C macros. This is because the RVV specification has a loose VLEN restriction, requiring just that it can contain at least one largest element (i.e. VLEN \u003e= ELEN). As a result, these N/A types may not be available on some chips (for example, an RV64V chip with VLEN = 64 cannot support SEW = 64, LMUL = 1/8). These types don’t seem to matter much, though, because the LMUL \u003c 1 case seems to be uncommon, and is usually used in widening instructions or narrowing instructions, which do not use those N/A types.\nThanks to LMUL, the amount of intrinsic types is huge, making the size of the header file and docs megabytes large. The good news is that RVV inrtinsics provide overloaded functions. But the names of these functions are essentially mapped to assembly instructions. There are a lot of functions that could be overloaded together while they aren’t. When you try to wrap them, you still need to do a lot of extra work, as stated in this issue.\nThese are just some small annoyances during my experience of RVV. I won’t use them to criticize RVV. The major problem is that these intrinsic types are all dynamically sized types (or sizeless types, or unsized types) due to RVV’s variable-length nature. And I’m afraid that DSTs are poorly supported in all languages, not just C.\nThe ecosystem has not prepared for DSTs First of all, the C language standard actually has a DST, i.e., the variable-length array. When a VLA is constructed, the current stack frame will be dynamically extended. It’s like alloca with some extra information such as type and lifetime. The implementation of RVV intrinsic types in Clang is very similar to VLA.\nHowever, while being supported as a compiler extension by GCC and Clang, VLA is not part of the C++ standard. C++ standard does not have any DST. As for Rust, although it does have DSTs like dyn Trait and [T], they can only be held indirectly using references or pointers. Dynamically extending stack frames is not possible with Rust at all. To properly support RVV, a number of issues must be taken into account, and maybe many changes must be made in these two languages. Consider these: How do you store RVV variables as static variables? How do you put them in a struct? How do you pass them as arguments to a function and return them from a function? None of these actions can be done on VLA variables. They are so fundamental and natural to any other SIMD type, but they pose a significant challenge to RVV.\nCurrently, the vast majority of existing C++ code are written against statically sized types. We rely on the static sizes in so many places without awareness. Have you ever think of that a sizeof in some constant evaluation context may break? What’s worse, DST is colored. If a struct contains a DST, then it is a DST, too. The suffering and sorrow spreads along the dependency chain.\nSo what is the status quo? If I recall properly, LLVM/Clang only allows RVV types to be used as local variables, arguments, and return values. Other than these, none of the aforementioned uses are allowed. While GCC’s support for RVV has stuck in an intermediate state for a long time (9/29/2022 update: GCC has supported RVV v1.0). As RVV is not the first vector architecture implementation, we can investigate the language support status for its predecessor, ARM SVE, to see how far we can go. Well, the support is, not less constrained than RVV.\nIs Rust better? Rust apparently possesses more language facilities for DSTs. It has a Sized trait used everywhere, implicitly or explicitly. And it permits structs with DST fields as long as they are the final ones (which is weird since Rust doesn’t guarantee the memory layout). So I believe that the process of Rust embracing RVV will be smoother. However, as was already said, Rust is unable to dynamically extend stack frames, making it impossible to even put a DST variable on the stack.\nActually, I seriously doubt that a language exists that supports DSTs well and can build zero-cost abstractions on top of them. Lack of ecosystem support suggests that RVV will be less consistent and composable in terms of language level.\nMaybe I’ve taken the problem too seriously, because scenarios that uses SIMD/Vector are quite specific. Even though RVV lacks so much abilities, you probably won’t get affected. But those SIMD library authors will. Their code design might automatically reject RVV. Putting aside the distinctions between SIMD and vectors, there is a more pressing issue: RVV types cannot be wrapped in a struct. In addition to SIMD libraries, GCC and Clang’s vector extension is also hard to support RVV as it requires you to specify the sizes at compile-time. That indicates that there isn’t a lot of SIMD-accelerated code can support RVV cheaply. By the way, Rust’s std::simd simply gives up supporting RVV for now.\nOnly Google’s highway pronounces support RVV, as far as I’m aware. However, some of its modules, such as vqsort, don’t. It is common for other sorting networks to employ transposes, but vqsort’s sorting network uses a number of permutations to avoid transposing, making it extremely challenging to convert to RVV because it is length-agnostic. It seems that nsimd tried to support RVV but stopped a long time ago.\nChoice of intrinsic types is not clear The SIMD type to employ is typically obvious. Numerous SIMD libraries, such as C++’s experimental , can choose an underlying SIMD type for you automatically. For instance, on x86 platforms, the fallback order is commonly AVX512 -\u003e AVX2 -\u003e SSE2, despite the fact that the time required to switch between licenses and the degree of downclocking of AVX512 and AVX2 differ amongst microarchitectures. And since you simply need to take into account the element type, it is also evident for ARM SVE. However, things become considerably more confusing in RVV.\nRecall that RVV has a LMUL parameter. Larger LMUL values are expected to increase speed at the expense of the number of available registers, which suggests a higher likelihood of spilling. You might need to tune LMUL to get a higher efficiency. I initially believed it to be a special procedure that only RVV possesses. But after a while, I noticed how similar it is to the loop unrolling problem.\nTo some extent, compilers can decide how to unroll loops for you. Then what about LMUL? Can compilers choose a proper value for you? I don’t know. But I think this is not as easy. Because LMUL is not an opt-in feature. You cannot pretend it always equals to one. Widening and narrowing instructions (e.g., convert u32 to u64 or the reverse) will change LMUL. Taken that into consideration, the optimizing process could be more complex than loop unrolling. It reminds me of how RISC-V’s genius design bring problems to linker implementations.\nIf the compiler is unable to select an appropriate LMUL for you, then you have to tune LMUL manually. Another issue now: can SIMD libraries offer a unified, cross-platform API over it? That is challenging, in my opinion, and I haven’t come across any related design.\nGiven the resemblance between selecting LMUL values and unrolling loops, I have to wonder if LMUL is really essential. Will the speedup warrant the additional complexity it adds? We don’t know because RVV hardware is currently scarce.\nPossible higher context switch cost The context size issue plagues older vector processors (according to some articles, though, I’m not familiar with that period of history). Their vector registers are typically made to be long in order to achieve a high speedup. This method will undoubtedly bloat the context size. As a result, operating systems must spend additional time and resources on register saving during context switching.\nThe RISC-V Reader, a popular resource for RISC-V newcomers, proudly claims that RVV can avoid this problem, because RVV has a dedicated instruction vsetdcfg that can enable / disable registers by need, so that we can only pay for what we use. Sounds promising, doesn’t it? However, The RISC-V Reader is very out-dated. The instruction vsetdcfg has already been deprecated in the current RVV spec. RVV now only has a very coarse-grained mechanism that records whether any vector register is modified or not. If the vendor chooses a long-length implementation, I believe RVV will also experience the context size issue. This problem is unlikely to bother you though. Super long vectors are usually designed for HPC, of which the resource is usually dedicated to one single program at a time.\nCan RVV emulate SIMD? Some blogs and talks say that RVV can, at worst, emulate SIMD. THIS IS NOT TRUE.\nThink of that, how can we use a stuff with less information (register sizes only known at run-time) to emulate a stuff with more information (register sizes known at compile-time)? To expose unified APIs to users, the only feasible way is to erase the extra information from SIMD types. And this is what highway does.\nBut can’t we set the desired size at run-time to match with SIMD? One might ask. No, you can’t. You must first deal with the DST issue, as I elaborated. And after that, you have to deal with the big variety of VLEN. Recall that the RVV Spec only stipulates VLEN \u003e= ELEN. So in some processors your vl settings might fail. What if we use LMUL to concat registers? Well, then you plunge into the type choosing problem.\nA way out is to use Zvl* extensions, which specifies the minimum vector register length. Theoretically, you can use feature flags (e.g., pre-defined macros like __AVX2__ in C++) to pick different implementations for different VLEN at compile-time or simply reject those platforms that don’t have sufficient length. Of course, once you do this, you lose the portability advantage of RVV. And even you use only a part of the register, the context size won’t be smaller. And as far as I know, such flags haven’t been implemented in LLVM/Clang yet.\nThat’s not the end. Despite all the challenges, there are some situations where SIMD emulation is still impossible (or too expansive), for instance, permutations. RVV does have some permutation instructions like slideup, slidedown, gather, scatter, and compress. And they are very helpful. You can also see some of them in AVX512. But SIMD’s general permutation instructions can do more than that; they accept a lookup table to rearrange elements within a register, which is not possible for RVV. As the length is agnostic, the lookup table size is unknown. Simdjson utilizes permutations to classify characters. Vqsort utilizes permutations to implement its sorting network. Neither of them can be cheaply emulated by RVV.\n","wordCount":"2565","inLanguage":"en","datePublished":"2022-02-27T00:00:00Z","dateModified":"2022-02-27T00:00:00Z","author":{"@type":"Person","name":"QuarticCat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.quarticcat.com/posts/rvv-may-not-be-as-good-as-you-think/"},"publisher":{"@type":"Organization","name":"QuarticCat's Blog","logo":{"@type":"ImageObject","url":"https://blog.quarticcat.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.quarticcat.com/ accesskey=h title="Home (Alt + H)"><img src=https://blog.quarticcat.com/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.quarticcat.com/zh/ title=中文 aria-label=中文>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://blog.quarticcat.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://blog.quarticcat.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.quarticcat.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.quarticcat.com/blogroll/ title=Blogroll><span>Blogroll</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">RVV may not be as good as you think</h1><div class=post-meta><span title='2022-02-27 00:00:00 +0000 UTC'>February 27, 2022</span>&nbsp;·&nbsp;QuarticCat</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#how-is-rvv-designed>How is RVV designed</a></li><li><a href=#annoyances-of-rvv-c-intrinsics>Annoyances of RVV C intrinsics</a><ul><li><a href=#data-types>Data Types</a></li><li><a href=#mask-types>Mask Types</a></li></ul></li><li><a href=#the-ecosystem-has-not-prepared-for-dsts>The ecosystem has not prepared for DSTs</a></li><li><a href=#choice-of-intrinsic-types-is-not-clear>Choice of intrinsic types is not clear</a></li><li><a href=#possible-higher-context-switch-cost>Possible higher context switch cost</a></li><li><a href=#can-rvv-emulate-simd>Can RVV emulate SIMD?</a></li></ul></nav></div></details></div><div class=post-content><p>As an emerging ISA, RISC-V learns a lot from its predecessors&rsquo; mistakes and brings some very appealing designs. In my circles, RISC-V is frequently associated with the words &ldquo;modern&rdquo; and &ldquo;elegant&rdquo;. Its vector extension (RVV) is often given equivalent praise, even though nearly no one has used a real-world RVV machine (including me) or even programmed in RVV. After experimenting with RVV for a while, I feel that it is not as good as many people claimed.</p><h2 id=how-is-rvv-designed>How is RVV designed<a hidden class=anchor aria-hidden=true href=#how-is-rvv-designed>#</a></h2><p>In contrast to SIMD architectures, RVV has variable-length vector registers. That means different chips (hardware threads, or harts, to be precise) can have different vector register lengths while sharing the same instruction set. To accomplish this, the software must get and set the length parameter with some instructions at runtime. RVV operations distinguish only between vector-vector and vector-scalar, signed and unsigned, but not element lengths. As a result, the element length is a dynamic parameter as well. Furthermore, RVV enables us to use only a portion of a vector register or to combine multiple vector registers, which necessitates the usage of a dynamic parameter. The type of a vector register is mainly governed by the factors listed below.</p><ul><li><code>VLEN</code>: a constant, represents the length of a vector register on this chip</li><li><code>vl</code>: a <em>Control and Status Register</em>, or CSR, controls the number of elements used in operations, making it easier to handle the tail elements of an array</li><li><code>vtype</code>: a CSR, includes<ul><li><code>vill</code>: represents whether the <code>vtype</code> configuration is ill-formed or not</li><li><code>vma</code> / <code>vta</code>: controls the operation behavior of those masked-off elements and tail elements</li><li><code>vsew</code>: controls the length of a single element, represented by <code>SEW = 8 | 16 | 32 | 64</code></li><li><code>vlmul</code>: controls how many registers are used in an operation, represented by <code>LMUL = 1/8 | 1/4 | 1/2 | 1 | 2 | 4 | 8</code></li></ul></li></ul><p>We use <code>vset{i}vl{i}</code> instructions to set both <code>vl</code> and <code>vtype</code>.</p><p>I need to elaborate on the parameter <code>LMUL</code>. When <code>LMUL = 1/2</code>, for example, we only use half of the registers. When <code>LMUL = 8</code>, we combine 8 contiguous registers into one, resulting in 32 / 8 = 4 accessible registers. Since there are only 5 bits for a register index in all RVV instructions, we don&rsquo;t receive more registers when <code>LMUL &lt; 1</code>.</p><p>There are a few other parameters. However, they will not be discussed in this blog, so I will not list them.</p><p>More details can be found in the <a href=https://github.com/riscv/riscv-v-spec>RVV Spec</a>. I&rsquo;ll end my introduction here.</p><h2 id=annoyances-of-rvv-c-intrinsics>Annoyances of RVV C intrinsics<a hidden class=anchor aria-hidden=true href=#annoyances-of-rvv-c-intrinsics>#</a></h2><p>In RVV C intrinsics, <code>vl</code>, <code>vma</code>, <code>vta</code> are specified at function invocations, whereas <code>vsew</code>, <code>vlmul</code> are hard-coded into types. Compilers are responsible to insert <code>vset{i}vl{i}</code> instructions for you. We now have the following horrible table (source: <a href=https://github.com/riscv-non-isa/rvv-intrinsic-doc/blob/master/rvv-intrinsic-rfc.md#type-system>RVV Intrinsic RFC</a>).</p><blockquote><h3 id=data-types>Data Types<a hidden class=anchor aria-hidden=true href=#data-types>#</a></h3><p>Encode <code>SEW</code> and <code>LMUL</code> into data types. We enforce the constraint <code>LMUL ≥ SEW/ELEN</code> in the implementation. There are the following data types for <code>ELEN</code> = 64.</p><table><thead><tr><th>Types</th><th>LMUL = 1</th><th>LMUL = 2</th><th>LMUL = 4</th><th>LMUL = 8</th><th>LMUL = 1/2</th><th>LMUL = 1/4</th><th>LMUL = 1/8</th></tr></thead><tbody><tr><td><strong>int64_t</strong></td><td>vint64m1_t</td><td>vint64m2_t</td><td>vint64m4_t</td><td>vint64m8_t</td><td>N/A</td><td>N/A</td><td>N/A</td></tr><tr><td><strong>uint64_t</strong></td><td>vuint64m1_t</td><td>vuint64m2_t</td><td>vuint64m4_t</td><td>vuint64m8_t</td><td>N/A</td><td>N/A</td><td>N/A</td></tr><tr><td><strong>int32_t</strong></td><td>vint32m1_t</td><td>vint32m2_t</td><td>vint32m4_t</td><td>vint32m8_t</td><td>vint32mf2_t</td><td>N/A</td><td>N/A</td></tr><tr><td><strong>uint32_t</strong></td><td>vuint32m1_t</td><td>vuint32m2_t</td><td>vuint32m4_t</td><td>vuint32m8_t</td><td>vuint32mf2_t</td><td>N/A</td><td>N/A</td></tr><tr><td><strong>int16_t</strong></td><td>vint16m1_t</td><td>vint16m2_t</td><td>vint16m4_t</td><td>vint16m8_t</td><td>vint16mf2_t</td><td>vint16mf4_t</td><td>N/A</td></tr><tr><td><strong>uint16_t</strong></td><td>vuint16m1_t</td><td>vuint16m2_t</td><td>vuint16m4_t</td><td>vuint16m8_t</td><td>vuint16mf2_t</td><td>vuint16mf4_t</td><td>N/A</td></tr><tr><td><strong>int8_t</strong></td><td>vint8m1_t</td><td>vint8m2_t</td><td>vint8m4_t</td><td>vint8m8_t</td><td>vint8mf2_t</td><td>vint8mf4_t</td><td>vint8mf8_t</td></tr><tr><td><strong>uint8_t</strong></td><td>vuint8m1_t</td><td>vuint8m2_t</td><td>vuint8m4_t</td><td>vuint8m8_t</td><td>vuint8mf2_t</td><td>vuint8mf4_t</td><td>vuint8mf8_t</td></tr><tr><td><strong>vfloat64</strong></td><td>vfloat64m1_t</td><td>vfloat64m2_t</td><td>vfloat64m4_t</td><td>vfloat64m8_t</td><td>N/A</td><td>N/A</td><td>N/A</td></tr><tr><td><strong>vfloat32</strong></td><td>vfloat32m1_t</td><td>vfloat32m2_t</td><td>vfloat32m4_t</td><td>vfloat32m8_t</td><td>vfloat32mf2_t</td><td>N/A</td><td>N/A</td></tr><tr><td><strong>vfloat16</strong></td><td>vfloat16m1_t</td><td>vfloat16m2_t</td><td>vfloat16m4_t</td><td>vfloat16m8_t</td><td>vfloat16mf2_t</td><td>vfloat16mf4_t</td><td>N/A</td></tr></tbody></table><p>There are the following data types for <code>ELEN</code> = 32.</p><table><thead><tr><th>Types</th><th>LMUL = 1</th><th>LMUL = 2</th><th>LMUL = 4</th><th>LMUL = 8</th><th>LMUL = 1/2</th><th>LMUL = 1/4</th><th>LMUL = 1/8</th></tr></thead><tbody><tr><td><strong>int32_t</strong></td><td>vint32m1_t</td><td>vint32m2_t</td><td>vint32m4_t</td><td>vint32m8_t</td><td>N/A</td><td>N/A</td><td>N/A</td></tr><tr><td><strong>uint32_t</strong></td><td>vuint32m1_t</td><td>vuint32m2_t</td><td>vuint32m4_t</td><td>vuint32m8_t</td><td>N/A</td><td>N/A</td><td>N/A</td></tr><tr><td><strong>int16_t</strong></td><td>vint16m1_t</td><td>vint16m2_t</td><td>vint16m4_t</td><td>vint16m8_t</td><td>vint16mf2_t</td><td>N/A</td><td>N/A</td></tr><tr><td><strong>uint16_t</strong></td><td>vuint16m1_t</td><td>vuint16m2_t</td><td>vuint16m4_t</td><td>vuint16m8_t</td><td>vuint16mf2_t</td><td>N/A</td><td>N/A</td></tr><tr><td><strong>int8_t</strong></td><td>vint8m1_t</td><td>vint8m2_t</td><td>vint8m4_t</td><td>vint8m8_t</td><td>vint8mf2_t</td><td>vint8mf4_t</td><td>N/A</td></tr><tr><td><strong>uint8_t</strong></td><td>vuint8m1_t</td><td>vuint8m2_t</td><td>vuint8m4_t</td><td>vuint8m8_t</td><td>vuint8mf2_t</td><td>vuint8mf4_t</td><td>N/A</td></tr><tr><td><strong>vfloat32</strong></td><td>vfloat32m1_t</td><td>vfloat32m2_t</td><td>vfloat32m4_t</td><td>vfloat32m8_t</td><td>N/A</td><td>N/A</td><td>N/A</td></tr><tr><td><strong>vfloat16</strong></td><td>vfloat16m1_t</td><td>vfloat16m2_t</td><td>vfloat16m4_t</td><td>vfloat16m8_t</td><td>vfloat16mf2_t</td><td>N/A</td><td>N/A</td></tr></tbody></table><h3 id=mask-types>Mask Types<a hidden class=anchor aria-hidden=true href=#mask-types>#</a></h3><p>Encode the ratio of <code>SEW</code>/<code>LMUL</code> into the mask types. There are the following mask types.</p><p>n = <code>SEW</code>/<code>LMUL</code></p><table><thead><tr><th>Types</th><th>n = 1</th><th>n = 2</th><th>n = 4</th><th>n = 8</th><th>n = 16</th><th>n = 32</th><th>n = 64</th></tr></thead><tbody><tr><td>bool</td><td>vbool1_t</td><td>vbool2_t</td><td>vbool4_t</td><td>vbool8_t</td><td>vbool16_t</td><td>vbool32_t</td><td>vbool64_t</td></tr></tbody></table></blockquote><p>There are a lot of N/A here, which makes it a little difficult to generate code with C macros. This is because the RVV specification has a loose <code>VLEN</code> restriction, requiring just that it can contain at least one largest element (i.e. <code>VLEN >= ELEN</code>). As a result, these N/A types may not be available on some chips (for example, an RV64V chip with <code>VLEN = 64</code> cannot support <code>SEW = 64, LMUL = 1/8</code>). These types don&rsquo;t seem to matter much, though, because the <code>LMUL &lt; 1</code> case seems to be uncommon, and is usually used in <a href=https://github.com/riscv/riscv-v-spec/blob/master/v-spec.adoc#102-widening-vector-arithmetic-instructions>widening instructions</a> or <a href=https://github.com/riscv/riscv-v-spec/blob/master/v-spec.adoc#103-narrowing-vector-arithmetic-instructions>narrowing instructions</a>, which do not use those N/A types.</p><p>Thanks to <code>LMUL</code>, the amount of intrinsic types is huge, making the size of the header file and docs megabytes large. The good news is that RVV inrtinsics provide <a href=https://github.com/riscv-non-isa/rvv-intrinsic-doc/blob/master/rvv-intrinsic-rfc.md#overloaded-interface>overloaded functions</a>. But the names of these functions are essentially mapped to assembly instructions. There are a lot of functions that could be overloaded together while they aren&rsquo;t. When you try to wrap them, you still need to do a lot of extra work, as stated in <a href=https://github.com/riscv-non-isa/rvv-intrinsic-doc/issues/117>this issue</a>.</p><p>These are just some small annoyances during my experience of RVV. I won&rsquo;t use them to criticize RVV. The major problem is that these intrinsic types are all <em>dynamically sized types</em> (or <em>sizeless types</em>, or <em>unsized types</em>) due to RVV&rsquo;s variable-length nature. And I&rsquo;m afraid that DSTs are poorly supported in all languages, not just C.</p><h2 id=the-ecosystem-has-not-prepared-for-dsts>The ecosystem has not prepared for DSTs<a hidden class=anchor aria-hidden=true href=#the-ecosystem-has-not-prepared-for-dsts>#</a></h2><p>First of all, the C language standard actually has a DST, i.e., the <a href=https://en.cppreference.com/w/c/language/array#Variable-length_arrays>variable-length array</a>. When a VLA is constructed, the current stack frame will be dynamically extended. It&rsquo;s like <code>alloca</code> with some extra information such as type and lifetime. The implementation of RVV intrinsic types in Clang is very similar to VLA.</p><p>However, while being supported as a compiler extension by GCC and Clang, VLA is not part of the C++ standard. C++ standard does not have any DST. As for Rust, although it does have DSTs like <code>dyn Trait</code> and <code>[T]</code>, they can only be held indirectly using references or pointers. Dynamically extending stack frames is not possible with Rust at all. To properly support RVV, a number of issues must be taken into account, and maybe many changes must be made in these two languages. Consider these: How do you store RVV variables as static variables? How do you put them in a struct? How do you pass them as arguments to a function and return them from a function? None of these actions can be done on VLA variables. They are so fundamental and natural to any other SIMD type, but they pose a significant challenge to RVV.</p><p>Currently, the vast majority of existing C++ code are written against statically sized types. We rely on the static sizes in so many places without awareness. Have you ever think of that a <code>sizeof</code> in some constant evaluation context may break? What&rsquo;s worse, DST is <a href=https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/>colored</a>. If a struct contains a DST, then it is a DST, too. The suffering and sorrow spreads along the dependency chain.</p><p>So what is the status quo? If I recall properly, LLVM/Clang only allows RVV types to be used as local variables, arguments, and return values. Other than these, none of the aforementioned uses are allowed. While GCC&rsquo;s support for RVV has stuck in an intermediate state for a long time (9/29/2022 update: <a href=https://github.com/riscv-collab/riscv-gnu-toolchain/issues/778>GCC has supported RVV v1.0</a>). As RVV is not the first vector architecture implementation, we can investigate the language support status for its predecessor, ARM SVE, to see how far we can go. Well, the support is, not less constrained than RVV.</p><p>Is Rust better? Rust apparently possesses more language facilities for DSTs. It has a <code>Sized</code> trait used everywhere, implicitly or explicitly. And it permits structs with DST fields as long as they are the final ones (which is weird since Rust doesn&rsquo;t guarantee the memory layout). So I believe that the process of Rust embracing RVV will be smoother. However, as was already said, Rust is unable to dynamically extend stack frames, making it impossible to even put a DST variable on the stack.</p><p>Actually, I seriously doubt that a language exists that supports DSTs well and can build <em>zero-cost abstractions</em> on top of them. Lack of ecosystem support suggests that RVV will be less consistent and composable in terms of language level.</p><p>Maybe I&rsquo;ve taken the problem too seriously, because scenarios that uses SIMD/Vector are quite specific. Even though RVV lacks so much abilities, you probably won&rsquo;t get affected. But those SIMD library authors will. Their code design might automatically reject RVV. Putting aside the distinctions between SIMD and vectors, there is a more pressing issue: RVV types cannot be wrapped in a struct. In addition to SIMD libraries, GCC and Clang&rsquo;s vector extension is also hard to support RVV as it requires you to specify the sizes at compile-time. That indicates that there isn&rsquo;t a lot of SIMD-accelerated code can support RVV cheaply. By the way, Rust&rsquo;s <code>std::simd</code> simply gives up supporting RVV for now.</p><p>Only Google&rsquo;s <a href=https://github.com/google/highway>highway</a> pronounces support RVV, as far as I&rsquo;m aware. However, some of its modules, such as vqsort, don&rsquo;t. It is common for other sorting networks to employ transposes, but vqsort&rsquo;s sorting network uses a number of permutations to avoid transposing, making it extremely challenging to convert to RVV because it is length-agnostic. It seems that <a href=https://github.com/agenium-scale/nsimd>nsimd</a> tried to support RVV but stopped a long time ago.</p><h2 id=choice-of-intrinsic-types-is-not-clear>Choice of intrinsic types is not clear<a hidden class=anchor aria-hidden=true href=#choice-of-intrinsic-types-is-not-clear>#</a></h2><p>The SIMD type to employ is typically obvious. Numerous SIMD libraries, such as C++&rsquo;s experimental <code>&lt;simd></code>, can choose an underlying SIMD type for you automatically. For instance, on x86 platforms, the fallback order is commonly AVX512 -> AVX2 -> SSE2, despite the fact that the time required to switch between licenses and the degree of downclocking of AVX512 and AVX2 differ amongst microarchitectures. And since you simply need to take into account the element type, it is also evident for ARM SVE. However, things become considerably more confusing in RVV.</p><p>Recall that RVV has a <code>LMUL</code> parameter. Larger <code>LMUL</code> values are expected to increase speed at the expense of the number of available registers, which suggests a higher likelihood of spilling. You might need to tune <code>LMUL</code> to get a higher efficiency. I initially believed it to be a special procedure that only RVV possesses. But after a while, I noticed how similar it is to the loop unrolling problem.</p><p>To some extent, compilers can decide how to unroll loops for you. Then what about <code>LMUL</code>? Can compilers choose a proper value for you? I don&rsquo;t know. But I think this is not as easy. Because <code>LMUL</code> is not an opt-in feature. You cannot pretend it always equals to one. Widening and narrowing instructions (e.g., convert <code>u32</code> to <code>u64</code> or the reverse) will change <code>LMUL</code>. Taken that into consideration, the optimizing process could be more complex than loop unrolling. It reminds me of how RISC-V&rsquo;s genius design bring <a href=https://maskray.me/blog/2021-03-14-the-dark-side-of-riscv-linker-relaxation>problems</a> to linker implementations.</p><p>If the compiler is unable to select an appropriate <code>LMUL</code> for you, then you have to tune <code>LMUL</code> manually. Another issue now: can SIMD libraries offer a unified, cross-platform API over it? That is challenging, in my opinion, and I haven&rsquo;t come across any related design.</p><p>Given the resemblance between selecting <code>LMUL</code> values and unrolling loops, I have to wonder if <code>LMUL</code> is really essential. Will the speedup warrant the additional complexity it adds? We don&rsquo;t know because RVV hardware is currently scarce.</p><h2 id=possible-higher-context-switch-cost>Possible higher context switch cost<a hidden class=anchor aria-hidden=true href=#possible-higher-context-switch-cost>#</a></h2><p>The context size issue plagues older vector processors (according to some articles, though, I&rsquo;m not familiar with that period of history). Their vector registers are typically made to be long in order to achieve a high speedup. This method will undoubtedly bloat the context size. As a result, operating systems must spend additional time and resources on register saving during context switching.</p><p><em>The RISC-V Reader</em>, a popular resource for RISC-V newcomers, proudly claims that RVV can avoid this problem, because RVV has a dedicated instruction <code>vsetdcfg</code> that can enable / disable registers by need, so that we can only pay for what we use. Sounds promising, doesn&rsquo;t it? However, <em>The RISC-V Reader</em> is very out-dated. The instruction <code>vsetdcfg</code> has already been deprecated in the current RVV spec. RVV now only has a very coarse-grained mechanism that records whether any vector register is modified or not. If the vendor chooses a long-length implementation, I believe RVV will also experience the context size issue. This problem is unlikely to bother you though. Super long vectors are usually designed for HPC, of which the resource is usually dedicated to one single program at a time.</p><h2 id=can-rvv-emulate-simd>Can RVV emulate SIMD?<a hidden class=anchor aria-hidden=true href=#can-rvv-emulate-simd>#</a></h2><p>Some blogs and talks say that RVV can, at worst, emulate SIMD. THIS IS NOT TRUE.</p><p>Think of that, how can we use a stuff with less information (register sizes only known at run-time) to emulate a stuff with more information (register sizes known at compile-time)? To expose unified APIs to users, the only feasible way is to erase the extra information from SIMD types. And this is what highway does.</p><p>But can&rsquo;t we set the desired size at run-time to match with SIMD? One might ask. No, you can&rsquo;t. You must first deal with the DST issue, as I elaborated. And after that, you have to deal with the big variety of <code>VLEN</code>. Recall that the RVV Spec only stipulates <code>VLEN >= ELEN</code>. So in some processors your <code>vl</code> settings might fail. What if we use <code>LMUL</code> to concat registers? Well, then you plunge into the type choosing problem.</p><p>A way out is to use <a href=https://github.com/riscv/riscv-v-spec/blob/master/v-spec.adoc#181-zvl-minimum-vector-length-standard-extensions><code>Zvl*</code> extensions</a>, which specifies the minimum vector register length. Theoretically, you can use feature flags (e.g., pre-defined macros like <code>__AVX2__</code> in C++) to pick different implementations for different <code>VLEN</code> at compile-time or simply reject those platforms that don&rsquo;t have sufficient length. Of course, once you do this, you lose the portability advantage of RVV. And even you use only a part of the register, the context size won&rsquo;t be smaller. And as far as I know, such flags haven&rsquo;t been implemented in LLVM/Clang yet.</p><p>That&rsquo;s not the end. Despite all the challenges, there are some situations where SIMD emulation is still impossible (or too expansive), for instance, permutations. RVV does have some permutation instructions like slideup, slidedown, gather, scatter, and compress. And they are very helpful. You can also see some of them in AVX512. But SIMD&rsquo;s general permutation instructions can do more than that; they accept a lookup table to rearrange elements within a register, which is not possible for RVV. As the length is agnostic, the lookup table size is unknown. <a href=https://github.com/simdjson/simdjson>Simdjson</a> utilizes permutations to classify characters. Vqsort utilizes permutations to implement its sorting network. Neither of them can be cheaply emulated by RVV.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.quarticcat.com/tags/risc-v/>Risc-V</a></li><li><a href=https://blog.quarticcat.com/tags/simd/>Simd</a></li><li><a href=https://blog.quarticcat.com/tags/vector/>Vector</a></li></ul><nav class=paginav><a class=prev href=https://blog.quarticcat.com/posts/optimize-difftastic/><span class=title>« Prev</span><br><span>How do I boost difftastic by 4x</span>
</a><a class=next href=https://blog.quarticcat.com/posts/one-more-nasty-design-of-cpp-name-lookup/><span class=title>Next »</span><br><span>One more nasty design of C++'s name lookup</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.quarticcat.com/>QuarticCat's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>